---
title:  "[ft_printf] ft_printf 개념"
excerpt: "ft_printf란?"

categories:
  - ft_printf
tags:
  - [42seoul, ft_printf]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.06.08 12:40:00
---

# ft_printf?
```c
int	ft_printf(const char *str, ...)
```
ft_printf, 이하 fp는 c의 `printf`함수를 구현해보는 과제이다.    

# ft_printf 과제에 필요한 개념들
1. [가변인자](#가변인자variable-argument)
2. [매크로 함수 / 인라인 함수](#매크로--인라인-함수)
3. [Printf - Format](#printf---format)
4. [Printf - Option]
5. [Escape squence]
5. [파싱]

***

# 가변인자(Variable Argument)
`ft_printf`의 매개변수 부분을 보면 명확한 변수 대신 `...`이 들어가 있는 것을 볼 수 있다.    
이는 변수의 개수와 타입이 정해져있지 않다는 의미이며, 이렇게 함수에 들어가는 인수가 변하는 것을 가변인자라고 한다.    
C에는 가변 인자를 사용하기 위한 매크로들이 `stdarg.h` 헤더에 정의되어있으며, 아래와 같은 매크로들을 통해 가변인자를 호출 및 처리할 수 있다.    
[참고한 블로그](https://blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=skout123&logNo=50132519670)    
* va_list
```c
typedef __builtin_va_list va_list;
```
우선 가변 인자 사용에 기본이 되는 자료형인 `va_list`를 알아두어야한다.    
`va_list`가 내부적으로 `char *`형으로 선언되어있다는 글들도 보이지만, gcc 컴파일러 상에서의 `va_list`는 `__builtin_va_list`형으로 정의되어있다. 이처럼 C표준에 정확히 명시되어있는 자료형은 아니고 운영체제나 컴파일러에 따라 구현이 다를 수 있다.    
어쨌든 가변 인자를 사용할때는 `va_list`로 선언한 포인터 자료형으로 다루게 된다.
* va_start
```c
#define va_start(ap, param) __builtin_va_start(ap, param)
```
`va_list`형으로 선언된 변수 ap를 초기화하는 매크로 함수이다.     
이 매크로 함수 역시 gcc 컴파일러 내부적으로 정의되어있으나, 위 링크한 글을 참고하면
```c
#define __builtin_va_start(ap, param) ( ap = (va_list)_ADDRESSOF(param) + _INTSIZEOF(param) )
```
과 유사하게 되어있을 것이라는걸 유추할 수 있다.    
`_ADDRESSOF` 매크로는 연산자 `&`와 같고, `_INTSIZEOF` 매크로는 받아오는 인자에 해당하는 자료형의 크기를 4의 배수로 올림해주는 역할을 한다. 즉 크기가 4바이트보다 작은 자료형(char, short 등)을 최소 4바이트로 맞추어주는데, 이는 스택 하나의 크기가 4바이트이기 때문에 이에 맞추모가 동시에 16비트, 32비트 등의 모든 환경에서도 동일하게 맞추어주기 위함이라고 한다.    
결국 `ap`는 고정인수 `param`의 시작주소에 해당 인수의 크기만큼 더해진 위치로 초기화되고, 이는 가변인수의 시작 주소가 된다.    
* va_arg
```c
#define va_arg(ap, type) __builtin_va_arg(ap, type)
#define __builtin_va_arg(ap, type) ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )
```
가변인수를 하나씩 넣어주는 매크로 함수이다.    
먼저 현재 포인터 `ap`의 값의 주소에 받고자 하는 인수의 크기만큼 더해주어 다음 인수를 받을 위치로 옮겨놓는다.    
이후 인수의 크기만큼 뺀 값을 인수의 자료형에 해당하는 포인터로 캐스팅한 값을 반환하여 사용한다.     
* va_copy
```c
#define va_copy(dest, src)  __builtin_va_copy(dest, src)
```
복사하는 시점의 포인터 `src`에 저장되어있는 주소값을 `dest`에 복사한다.    
`dest`와 `src`는 독립적으로 사용된다.    
* va_end
```c
#define va_end(ap) __builtin_va_end(ap)
#define __builtin_va_end(ap) ( ap = (va_list)0 )
```
포인터 `ap`에 `0`, 즉 `NULL`을 대입하여 안전하게 가변인수 사용과정을 종료한다.    

***

# 매크로 / 인라인 함수

## 매크로 함수
매크로 함수란 `#define`으로 정의한 함수를 뜻한다.    
`#`으로 시작하는 구문은 전처리기가 처리하기 때문에, 매크로 함수 역시 전처리기가 처리하게 된다.    
전처리기는 컴파일러와는 달리 우선순위를 고려하지 않기 때문에 매크로 함수 사용시 괄호를 적절하게 사용하지 않으면 사용자가 원하는 결과가 나오지 않을 수 있다. 간단한 예시는 다음과 같다.    
```c
#define square(x) x * x

int	main()
{
	printf("%d, %d", square(5), square(5 + 1));
	return (0);
}
```
해당 코드의 실행결과는 `25, 11, 0`이다.    
두번째 값이 36으로 출력되지 않은 이유는, 5 + 1이 우선순위 고려 없이 그대로 대입되었기 때문이다. 즉 `5 + 1 * 5 + 1`으로 대입되어 계산된 결과이다.   

## 인라인 함수
[참고한 글](https://boycoding.tistory.com/220)    
매크로 함수에는 앞서 말한 단점이 있기 때문에, 함수를 전처리기가 아닌 컴파일러가 처리하도록 만든 것이 인라인 함수이다.     
아래와 같이 함수 앞에 `inline`을 표기하면 인라인 함수가 된다.    
```c
inline int min(int x, int y)
{
	return x > y ? y : x;
}
```
인라인 함수와 일반 함수와의 차이점은 호출에 있다.    
일반 함수는 호출될 때마다 해당 함수가 저장되어있는 메모리에 접근하고, 해당 메모리에 인자를 전달하여 `return`값을 함수를 호출했던 곳의 메모리로 가지고 오게 된다. 반면 인라인 함수는 호출과정 없이 해당 함수를 함수를 호출했던 곳으로 그대로 복사해온 후 그 내용을 수행하여 더 향상된 성능을 발휘한다.    
따라서 함수 호출에 필요한 시간이 실제로 함수 코드를 실행하는데 필요한 시간보다 많은 작은 함수의 경우 인라인 함수로 사용하는 것이 유리하며, 이미 최신 컴파일러에서는 인라인으로 만들시 성능이 향상될 것 같은 함수들을 자동으로 인라인화하여 사용한다.    
다만, 인라인 함수가 여러번 호출된다는 것은 함수가 여러번 복사된다는 것과 같은 의미이고, 따라서 메모리적으로 불리해질 수 있기에 모든 경우에서 유리한 것은 아니라고 한다. 그래서 보통은 단순한 함수에만 써먹는 듯 하다.    

# Printf - Format
||설명|약어|
|:---|:---|:---|
|d, i| 부호 있는 10진 정수, 단 입력서식으로 사용할경우 사용법이 달라짐에 주의 |`signed decimal / integer`|
|u| 부호 없는 10진 정수 |
|o| 부호 없는 8진 정수 |
|x, X| 부호 없는 16진수 정수(소문자 / 대문자) |
|f, F| 소수점으로 표기된 실수(소문자 / 대문자) |
|e, E| 부동소수점으로 표기된 실수(소문자 / 대문자) |
|g, G| 숫자의 절대치가 precision의 자릿수를 넘는 경우 + 숫자의 절대값이 0.0001보다 작은 경우 `e/E`, 그 외의 경우 `f/F`형식 출력 |
|a, A| 16진수로 표기 실수(소문자 / 대문자) |
|c| 문자 |
|s| 문자열 | 
|p| 포인터의 메모리 주소 |
|n| 
|%| `%` |
