---
title:  "[ft_printf] ft_printf 개념"
excerpt: "ft_printf란?"

categories:
  - ft_printf
tags:
  - [42seoul, ft_printf]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.06.08 12:40:00
---

# ft_printf?
```c
int	ft_printf(const char *str, ...)
```
ft_printf, 이하 fp는 c의 `printf`함수를 구현해보는 과제이다.    

# ft_printf 과제에 필요한 개념들
1. [가변인자](#가변인자variable-argument)
2. [매크로 함수 / 인라인 함수]
3. [Printf]
4. [Escape squence]
5. [파싱]

***

# 가변인자(Variable Argument)
`ft_printf`의 매개변수 부분을 보면 명확한 변수 대신 `...`이 들어가 있는 것을 볼 수 있다.    
이는 변수의 개수와 타입이 정해져있지 않다는 의미이며, 이렇게 함수에 들어가는 인수가 변하는 것을 가변인자라고 한다.    
C에는 가변 인자를 사용하기 위한 매크로들이 `stdarg.h` 헤더에 정의되어있으며, 아래와 같은 매크로들을 통해 가변인자를 호출 및 처리할 수 있다.    
[참고한 블로그](https://blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=skout123&logNo=50132519670)    
* va_list
```c
typedef __builtin_va_list va_list;
```
우선 가변 인자 사용에 기본이 되는 자료형인 `va_list`를 알아두어야한다.    
`va_list`가 내부적으로 `char *`형으로 선언되어있다는 글들도 보이지만, gcc 컴파일러 상에서의 `va_list`는 `__builtin_va_list`형으로 정의되어있다. 이처럼 C표준에 정확히 명시되어있는 자료형은 아니고 운영체제나 컴파일러에 따라 구현이 다를 수 있다.    
어쨌든 가변 인자를 사용할때는 `va_list`로 선언한 포인터 자료형으로 다루게 된다.
* va_start
```c
#define va_start(ap, param) __builtin_va_start(ap, param)
```
`va_list`형으로 선언된 변수 ap를 초기화하는 매크로 함수이다.     
이 매크로 함수 역시 gcc 컴파일러 내부적으로 정의되어있으나, 위 링크한 글을 참고하면
```c
#define __builtin_va_start(ap, param) ( ap = (va_list)_ADDRESSOF(param) + _INTSIZEOF(param) )
```
과 유사하게 되어있을 것이라는걸 유추할 수 있다.    
`_ADDRESSOF` 매크로는 연산자 `&`와 같고, `_INTSIZEOF` 매크로는 받아오는 인자에 해당하는 자료형의 크기를 4의 배수로 올림해주는 역할을 한다. 즉 크기가 4바이트보다 작은 자료형(char, short 등)을 최소 4바이트로 맞추어주는데, 이는 스택 하나의 크기가 4바이트이기 때문에 이에 맞추모가 동시에 16비트, 32비트 등의 모든 환경에서도 동일하게 맞추어주기 위함이라고 한다.    
결국 `ap`는 고정인수 `param`의 시작주소에 해당 인수의 크기만큼 더해진 위치로 초기화되고, 이는 가변인수의 시작 주소가 된다.    
* va_arg
```c
#define va_arg(ap, type) __builtin_va_arg(ap, type)
#define __builtin_va_arg(ap, type) ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )
```
가변인수를 하나씩 넣어주는 매크로 함수이다.    
먼저 현재 포인터 `ap`의 값의 주소에 받고자 하는 인수의 크기만큼 더해주어 다음 인수를 받을 위치로 옮겨놓는다.    
이후 인수의 크기만큼 뺀 값을 인수의 자료형에 해당하는 포인터로 캐스팅한 값을 반환하여 사용한다.     
* va_copy
```c
#define va_copy(dest, src)  __builtin_va_copy(dest, src)
```
복사하는 시점의 포인터 `src`에 저장되어있는 주소값을 `dest`에 복사한다.    
`dest`와 `src`는 독립적으로 사용된다.    
* va_end
```c
#define va_end(ap) __builtin_va_end(ap)
#define __builtin_va_end(ap) ( ap = (va_list)0 )
```
포인터 `ap`에 `0`, 즉 `NULL`을 대입하여 안전하게 가변인수 사용과정을 종료한다.    

***

# 매크로 / 인라인 함수

## 매크로 함수
매크로 함수란 `#define`으로 정의한 함수를 뜻한다.    
`#`으로 시작하는 구문은 전처리기가 처리하기 때문에, 매크로 함수 역시 전처리기가 처리하게 된다.    
전처리기는 컴파일러와는 달리 우선순위를 고려하지 않기 때문에 매크로 함수 사용시 괄호를 적절하게 사용하지 않으면 사용자가 원하는 결과가 나오지 않을 수 있다. 간단한 예시는 다음과 같다.    
```c
#define square(x) x * x

int	main()
{
	printf("%d, %d", square(5), square(5 + 1));
	return (0);
}
```
해당 코드의 실행결과는 `25, 11, 0`이다.    
두번째 값이 36으로 출력되지 않은 이유는, 5 + 1이 우선순위 고려 없이 그대로 대입되었기 때문이다. 즉 `5 + 1 * 5 + 1`으로 대입되어 계산된 결과이다.   

## 인라인 함수
[참고한 글](https://boycoding.tistory.com/220)    