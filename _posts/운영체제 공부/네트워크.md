<1, 2, 3강>

네트워크 : 노드(네트워크에 속한 통신 장비)들이 데이터를 공유할 수 있게 하는 통신망
인터넷 : 세상에서 가장 큰 네트워크
www : 인터넷을 통해 웹과 관련된 데이터를 공유

크기에 따른 분류 : LAN / WAN
LAN(Local Area Network) : 가까운 지역을 하나로 묶은 네트워크
WAN(Wide Area Network) : 멀리 있는 지역을 한데 묶은 네트워크, LAN들을 연결시켜놓은 것

연결 형태에 따른 분류 : Star / Mesh / Tree / 기타 ...
Star형(선형) : 중앙 장비에 모든 노드가 연결됨, LAN 대역을 만들 때 주로 사용함, 가정집의 공유기 등
Mesh형(망형) : 여러 노드들이 서로 그물처럼 연결
혼합형

네트워크 통신방식 : 유니 캐스트 / 멀티 캐스트 / 브로드 캐스트
유니 캐스트 : 특정 대상과 1:1로 통신
멀티 캐스트 : 특정 다수와 1:N으로 통신
브로드 캐스트 : 같은 네트워크에 있는 모든 대상과 통신

프로토콜 : 노드와 노드가 통신할 때 어떤 노드가 어느 노드에게 어떤 데이터를 어떻게 보내는지 작성하기위한 일종의 약속/양식.
가까운곳 - Ethernet (MAC 주소)
멀리있는 곳 - ICMP / IPv4 / ARP (IP 주소)
여러가지 프로그램으로 연략 - TCP / UDP (포트 번호)

tracert 8.8.8.8 : google dns서버와 통신하기 위해 거쳐간 네트워크 LAN 대역들 추적
Wireshark : 프로토콜 추적. IPV4(장거리), Ethernet(단거리), TCP(프로그램) 등등...


***


<4강>

TCP/IP 모델 / OSI 7계층 모델
공통점 : 계층적 네트워크 모델, 계층간 역할 정의
차이점 : 계층의 수, OSI는 역할기반 / TCP/IP는 프로토콜 기반, OSI는 통신 전반에 대한 표준 / TCP/IP는 데이터 전송기술 특화

패킷 : 네트워크 상에서 전달되는 데이터를 통칭하는 말. 블록단위. 제어 정보 / 사용자 데이터(페이로드)
헤더 - 페이로드 - 풋터(잘 사용 안함)
여러 프로토콜들로 캡슐화된 패킷 - [IPv4(헤더) / [TCP(헤더) / HTTP(페이로드)](페이로드)] ...
페이로드의 프로토콜을 헤더로 붙이는 과정 = 캡술화(반대는 decapsulation), 내가 누군가에게 패킷을 보낼 때 사용, 상위 계층에서부터 하위계층으로 내려가며 프로토콜을 붙임.
계층별 패킷의 이름 = PDU(Protocol data unit) : 4계층(tcp/데이터) - 세그먼트, 3계층 - 패킷, 2계층 - 프레임


***


<5강>

2계층 : 하나의 네트워크 대역(같은 네트워크 상)에 존재하는 여러 장비들 중에서 어떤 장비가 어떤 장비에게 보내는 데이터를 전달, 오류제어 / 흐름제어
다른 네트워크와 통신할 때는 3계층이 필요함
MAC주소 : 물리적인 주소, 16진수 6개(OUI-제조회사 식별 ID / 고유번호) = 6바이트

Ethernet 프로토콜 : Preamble(8바이트) > Destination Address(6바이트) = 목적지 Mac주소 > Source Address(6바이트) = 출발지 Mac주소 > Ethernet Type(2바이트) = 상위 프로토콜 타입(페이로드에 있는 3계층 프로토콜의 종류를 지정) > DATA


***


<6강>

3계층 : 다른 네트워크 대역들끼리의 데이터를 전달, ARP 프로토콜 / IPv4 프로토콜 / ICMP 프로토콜
IPv4 주소 - 현재 PC에 할당된 IP주소 / 서브넷 마스크 - IP주소에 대한 네트워크의 대역 규정 / 게이트웨이 주소 - 외부와 통신할 때 사용하는 네트워크의 출입구

일반적인 IP주소 : 1바이트 4개
Classful IP : A~E클래스, 낭비가 심함 / Classless IP : 하나의 큰 네트워크를 여러개의 작은 네트워크로 쪼개서 사용
서브넷마스크 : 네트워크 대역 구분에 사용하는 영역과 호스트 구분에 사용하는 영역을 지정
ex) 11111111. 11111111. 11111111. 11000000인경우 1과 0의 경계가 네트워크 대약과 호스트를 구분하는 영역의 경계가 됨.

사설IP / 공인IP : 공인IP(인터넷과 통신할때 사용하는 IP주소) 1개당 2^32개의 사설IP(같은 네트워크 대역에서 사용하는 IP주소)
실제 인터넷 세상에서는 공인IP로만 통신 - 외부 네트워크 대역에서는 사설IP대역이 보이지 않음. 사설IP의 구분은 공유기가 해줌 > 서버는 공인IP사용 혹은 공유기에 추가적인 설정
NAT(Network Address Translation) : 특정 IP를 다른 특정 IP로 전환하는 기술, 네트워크 주소를 사설IP에서 공인IP로 전환하는데 사용

특수 IP
* 0.0.0.0(Wildcard) - 나머지 모든 IP
* 127.0.0.* - 자기 자신을 나타내는 주소
* 게이트웨이 주소 - 일반적으로는 공유기 IP. 보통 네트워크 대역에서 쓸 수 있는 IP중 가장 작거나 가장 큰 IP를 사용.


***


<7강, 8강>

ARP 프로토콜 : 같은 네트워크 대역에서 통신을 하기 위해 필요한 MAC주소를 IP주소를 이용해 알아오는 프로토콜

하드웨어 타입(2바이트) : 대부분 이더넷 - 0001 > 프로토콜 타입(2바이트) : 대부분 IPv4 - 0800 
> 하드웨어 주소(Mac주소) 길이(1바이트) = 06 > 프로토콜 주소(IPv4주소) 길이(1바이트) = 04 
> Opcode(2바이트) : Operation code, 두가지 - 요청 = 0001 / 응답 = 0002 
> Source 하드웨어 주소(6바이트) = 출발지 Mac주소 > Source 프로토콜 주소(4바이트) = IPv4주소 
> Destination 하드웨어 주소(6바이트) = 목적지 Mac주소 > Destination 프로토콜 주소(4바이트)

ARP요청 - 목적지 Mac주소는 0으로, 캡슐화 과정에서 이더넷 목적지 Mac주소는 FF FF FF FF FF FF로(브로드캐스트)
> 스위치(2계층장비)에서 2계층 프로토콜까지 확인(이더넷 프로토콜만)하여 네트워크 대역에있는 모두에게 보냄
> 3계층 확인 - 목적지 IP주소 확인, 같지않으면 패킷 버림
> ARP 응답
> ARP 캐시 테이블에 해당 IP에 대한 Mac주소 기록

ARP는 3계층이지만 같은 네트워크 대역에서만 쓰임 - 3계층장비에 브로드캐스트가 온 경우 외부로 보내지 않음
패딩 - 프레임의 최소 단위(60바이트)를 맞춰주기 위해, 최대는 일반적으로 1514바이트


***


<9깅, 10강, 11강>

IPv4 : 네트워크 상에서 데이터를 교환하기 위한 프로토콜, 정확한 전달을 보장하지는 않음(중복된 패킷, 순서 잘못 전달 등) - 데이터의 정확성은 상위 프로토콜인 TCP에서 보장

Version(0.5바이트) - 무조건 4만 옴 > IHL(Header length, 0.5바이트) - 프로토콜 전체 길이 / 4 
> Type of Service(TOS, 1바이트) - 현재는 쓰이지 않아서 0으로 비워둠 > Total length(2바이트) - 페이로드까지 합쳐진 총 길이
> Identification(2바이트) - 나뉘어진 데이터들을 복원할 때 같은 Id값인지 확인 
> IP Flags(0.75바이트, xDM) - x는 안씀, D는 최대전송단위보다 크게 보낼때(거의 안씀), M은 조각화가 되어있을 경우 패킷이 더있음을 표시 
> Fragment Offset(3.25바이트) - 데이터의 시작부분으로부터 얼만큼 떨어져있는 조각인지 표시하여 복원시에 사용
> Time To Live(TTL, 1바이트) - 패킷이 살아있을 수 있는 시간 지정 (운영체제마다 설정값 다름) > Protocol(1바이트) - 상위 프로토콜 지정 > Header Checksum - 헤더의 오류 확인
> 출발지 주소(6바이트) > 목적지 주소(6바이트) > IP Option - 각 옵션마다 4바이트, 없을수도있고 최대 60바이트까지

ICMP(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜) : 운영체제에서 오류메시지를 전송받는데 쓰임 - 상대방이랑 통신이 되는지 확인 등 ...

Type(1바이트) - 대분류
	0번 : Echo Reply(응답) / 8번 : Echo(요청) /  5번 : Redirect - 원격지의 상대방 라우팅테이블을 수정
	3번 : Destination Unreachable(목적지 도달 실패) - 경로상 문제 / 11번 : Time Exceded(요청시간만료) - 상대방 문제(방화벽 등)
> Code(1바이트) - 소분류 > Checksum(2바이트) > Other message specific information...(4바이트)


***


<12강, 13강>

라우팅 테이블 : 패킷을 송신할 최적의 경로를 저장해놓은 테이블, `netstat -r`로 확인가능, 라우팅 테이블에 적혀있지 않은 대역은 찾아갈 수 없음
기본값 지정 - 0.0.0.0(네트워크 대상 / 대역) / 0.0.0.0(네트워크 마스크) / 192.168.0.1(게이트웨이) / 192.168.0.189(인터페이스) / 276(메트릭)
이더넷의 목적지 Mac주소는 라우팅테이블에서 가리킨 대상의 주소로 사용 - 이더넷 프로토콜은 네트워크 대역이 바뀔때마다 새로 작성됨


***


<14강, 15강>

IPv4 조각화
MTU (Maximum Transmission Unit) : 패킷이 MTU보다 클 경우(보통 1500바이트) 여러개의 작은 패킷으로 조각화시켜 전송되어야함
조각화되면 최종 목적지까지는 재조립되지 않는것이 일반적, IPv4에서는 발신지 및 중간 라우터에서 IP 조각화가 가능 / IPv6에서는 발신지에서만 가능
ex) MTU가 3300바이트이면 IPv4 프로토콜의 길이 20바이트를 뺀 나머지가 데이터 크기
MF(More Flag) - 0010 = 2, Offset - 데이터크기 / 8
ICMP 프로토콜은 마지막 패킷에만 붙임
이더넷은 조각화 후 나중에 붙임
나뉘어진 패킷들의 id값은 모두 동일함


***


<16강, 17강, 18강>

4계층 프로토콜(전송 계층, Transport layer) : 송신자와 수신자의 프로세스를 연결하는 통신 서비스, TCP / UDP

포트 번호 : 특정 프로세스들끼리 통신하기위해 사용, 하나의 포트는 하나의 프로세스만 사용 가능 / 하나의 프로세스가 여러 포트를 사용하는 것은 가능
	일반적으로는 정해져있지만(ex - 웹서비스는 80번 포트) 무조건 지켜야하는 것은 아님, 0-65535
	* Well-known 포트 : 매우 유명, 0-1024, FTP(20, 21) / SSH(22) / TELNET(23) / DNS(53) / DHCP(67, 68) / TFTP(69) / HTTP(80) / HTTPS(443) ...
	* Registered 포트 : 조금 유명, 1024-49151, 오라클DB 서버(1521) / MYSQL 서버(3306) / MS 원격 데스크탑(3389) ...
	* Dynamic 포트 : 일반 프로그램들이 사용, 49152-65535

활성 연결 테이블 : 현재 포트 활성 여부 확인, `netstat -ano`


***


<19강, 20강>

UDP(User(혹은 Universal) Datagram Protocol, 사용자 데이터그램 프로토콜) : 단순한 전송방식 > 신뢰성 낮음 > 오류 검사 / 수정 필요없는 프로그램에서 수행할 것으로 가정
Source Port(2바이트) > Destination Port(2바이트) > Length(2바이트) > Checksum(2바이트)
대표적으로 DNS 서버(도메인에 대한 IP를 알려줌) / tftp(파일 공유) 서버 / RIP 프로토콜(라우팅 정보를 공유)에서 UDP 프로토콜을 사용


***


<21강, 22강, 23강, 24강, 25강>

TCP(Transmission Contro Protocol) : 인터넷에 연결된 컴퓨터에서 실행되는 프로그램간의 안정적 통신에 사용, 안정성이 필요없는경우 더 빠른 UDP 사용

Source Port(2바이트) > Destination Port(2바이트) > Sequence Number(4바이트) > Acknowledgment Number(4바이트)
> Offset(0.5바이트) - 헤더길이 / 4 > Reserved(0.5바이트) - 예약, 사용하지않는 필드 > TCP Flags(1바이트) > Window(2바이트) - 남아있는 TCP 버퍼 공간을 확인
> Checksum(2바이트) > Urgent Pointer(2바이트)
> TCP Options(variable length, optional)

TCP Flag
* C E
* U(urgent) : 긴급, Urgent Pointer로 해당 데이터의 위치를 알려줌
* A(Acknowledgment) : 승인, 요청에 대한 승인
* P(Push) : 밀어넣기, TCP버퍼가 일정 크기만큼 쌓이지 않아도 데이터를 밀어넣음
* R(Reset) : 초기화, 연결이 되어있는 상태에서 문제 발생시 초기화
* S(Syn) : 동기화, 상대방과 연결을 시작할 때 무조건 사용
* F(Fin) : 종료, 연결을 끊을 때 사용

TCP 통신과정
* 연결 수립 과정 : 가장 먼저 수행
	1. 클라이언트가 서버에게 요청 패킷을 보냄 - Sequence number = random값 생성 / Acknowledgment number = 0
	2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보냄 - Sequence number = random값 생성 / ACK number = 받은 sequence number + 1
	3. 클라이언트가 최종적으로 수락하는 패킷을 보냄 - Sequence number = 받은 ACK number / ACK number = 받은 sequence number + 1
	> 3Way Handshake
* 데이터 송수신 과정
	1. 보낸 쪽에서 또 보낼때는 SEQ / ACK 번호를 그대로 사용, 플래그는 PSH + ACK
	2. 받는 쪽의 SEQ 번호는 받은 ACK 번호가 됨
	3. 받는 쪽의 ACK 번호는 받은 SEQ 번호 + 데이터 크기

TCP 상태전이도 : 실선(클라이언트) / 점선(서버)
* ClOSE_WAIT / LAST_ACK / CLOSED / SYN_RCVD / SYN_SENT / FIN_WAIT
* LISTEN - 포트 번호를 열어놓고있는 상태(포트 번호를 서버쪽 프로그램이 사용하고 있는 상태) = 클라이언트의 요청을 듣고있는 상태
* ESTABLISHED - 연결이 수립된 상태
클라이언트는 active / 서버는 passive


***


<26강, 27강>

NAT(Network Address Translation) : IP패킷의 TCP/UDP 포트 숫자와 출발지/목적지의 IP 주소 등을 재기록, 라우터를 통해 네트워크 트래픽을 주고받음
	특정 IP주소의 특정 포트번호로 가는 패킷을 다른 IP주소의 다른 포트번호로 바꿔줌
	사설IP를 공인IP로 변환하는데 사용

포트포워딩 : 특정 IP주소와 포트 번호의 통신 요청을 특정 다른 IP와 포트 번호로 넘겨주는 NAT의 응용, 게이트웨이(외부망)의 반대쪽에 위치한 사설네트워크에 상주하는 호스트에 대한 서비스를 생성하기 위해 흔히 사용됨


***


<28강, 29강, 30강, 31강, 32강>

웹에 사용되는 기술들
* HTTP - 웹 표준 데이터를 받아오는 프로토콜, HTTPS - 보안요소 추가
* HTML - 웹 페이지를 채울 내용 / Javascript - 웹 페이지에 들어갈 기능 / CSS - 웹 페이지를 꾸밀 디자인 
	> 프론트엔드
* ASP/ASP.NET - MS / JSP - Java 기반 / PHP 
	> 웹 서버 페이지를 만드는 기술 - 서버쪽에서 동작, 백엔드
* DB

7계층 - HTTP(HyperText Transfer Protocol) : www에서 쓰이는 핵심 프로토콜, 오늘날 거의 모든 웹 어플리케이션에서 사용, Request / Response 동작에 기반하여 서비스 제공
	1.0 : 연결 수립 / 동작 / 해제의 단순함 - 하나의 URL은 하나의 TCP 연결
		데이터를 전송받은 뒤 연결을 끊고 다시 연결하여 데이터 전송 > 단순동작 반복으로 통신 부하 문제 발생
	1.1 : 연결 후 요청 여러개를 받은 후 연결 종료

HTTP 요청 프로토콜
구조 : Request Line / Headers(옵션같은 개념) / 공백(한줄) / Body
* Request Line - 요청 타입 > 공백 > URI > 공백 > HTTP 버전(주로 1.1)
	* 요청 타입 - !GET(클라이언트가 서버에게 데이터를 요청, 요청하면서 데이터를 보낼 수 있음) / HEAD(특정 정보) / !POST(클라이언트가 서버에 데이터를 전송, 전송하면서 요청 가능) / PUT(업로드) / PATCH / COPY / MOVE / DELETE / LINK / UNLINK / OPTION
		GET은 데이터를 URL에 포함시켜보냄 - 노출되므로 중요한 데이터는 불가능, POST는 Body로 보냄 - 중요한 데이터 가능
	* URI(Uniform Resource Identifier) : 인터넷 상에서 특정 자원(파일)을 나타내는 유일한 주소
		scheme :// host[:port][/path][?query]
		scheme(요청하는 요청 형식 지정, http 등)://IP주소:포트(or 도메인주소, 포트는 80 또는 443을 생략)/폴더이름/파일이름?query(사용자가 전달하는 데이터)


***


<33강>

HTTP 응답 프로토콜
구조 : Status Line / Headers(옵션같은 개념) / 공백(한줄) / Body
* Status LIne - HTTP 버전 > 공백 > 상태 코드 > 공백 > 상태 문구
	* 상태 코드
		100-199 : 단순한 정보
		!200-299 : Client의 요청이 성공
			200 - 상태문구 OK / Client의 요청이 성공
		300-399 : Client의 요청이 수행되지 않아 다른 URL로 재지정
		!400-499 : Client의 요청이 불완전하여 다른 정보가 필요
			403 - 상태문구 Forbidden / Client가 권한이 없는 페이지 요청
			404 - 상태문구 Not Found / Client가 서버에 없는 페이지 요청 
		!500-599 : Server의 오류를 만나거나 Client의 요청 수행 불가
			500 - 상태문구 Internal Server Error / Server의 일부가 멈췄거나 설정 오류가 발생
			503 - 상태문구 Service Unavailable / 최대 Session 수를 초과
* 헤더 - 일반 / 요청, 응답 / 항목
	일반 헤더
		* Content-Length : 메시지 바디 길이
		* Content-Type : 메시지 바디에 들어있는 컨텐츠 종류(HTML문서는 text/html 등)
	요청 헤더
		* Cookie : 서버로부터 받은 쿠키를 다시 서버에게 보내줌
		* Host : 요청된 URL에 나타난 호스트명을 상세히 표시, HTTP1.1에서는 요청시 필수
		* User-Agent : Cilent Program에 대한 식별 가능 정보를 제공
	응답 헤더
		* Server : 사용하고있는 웹서버의 소프트웨어에 대한 정보
		* Set-Cookie : 쿠키를 생성하고 브라우저에 보냄, 해당 쿠키값을 브라우저가 서버에 다시 보낼 때 사용
