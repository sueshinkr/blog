---
title:  "Chapter 02 - 소켓의 타입과 프로토콜의 설정"
excerpt: "Part 01"

categories:
  - 열혈 TCP/IP 소켓 프로그래밍
tags:
  - [net, Server]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2023.01.08 11:00:00
---

# Chapter 02 - 소켓의 타입과 프로토콜의 설정

## 02-1 : 소켓의 프로토콜과 그에 따른 데이터 전송 특성

***

## 02-2 : 윈도우 기반에서 이해 및 확인하기

***
***

# 내용 확인문제

1. 프로토콜이란 무엇을 의미하는가? 그리고 데이터의 송수신에 있어서 프로토콜을 정의한다는 것은 어떤 의미가 있는가?    

<br/>

2. 연결지향형 소켓인 TCP 소켓의 전송 특성 세가지를 나열하여라.    

<br/>

3. 다음 중 비 연결형 소켓의 특성에 해당하는 것을 모두 고르면?
* 전송된 데이터는 손실될 수 있다.
* 데이터의 경계(Boundary)가 존재하지 않는다. 
* 가장 빠른 전송을 목표로 한다.
* 한번에 전송할 수 있는 데이터의 크기가 제한되어있지 않다.
* 연결지향형 소켓과 달리 연결이라는 개념이 존재하지 않는다.

<br/>

4. 다음 유형의 데이터 송수신에 적합한 타입의 소켓은 무엇인지 결정하고, 그러한 결정을 하게 된 이유를 설명해보자.
* 서태지와 아이들의 실시간 라이브 방송 멀티미디어 데이터
* 철수가 압축한 텍스트 파일의 전송
* 인터넷 뱅킹을 이용하는 고객과 은행 사이에서의 데이터 송수신

<br/>

5. 데이터의 경계(Boundary)가 존재하지 않는 소켓은 어떠한 타입의 소켓인가? 그리고 이러한 소켓은 데이터를 수신할 때 무엇을 주의해야하는지 서술해보자.    

<br/>

6. `tcp_server.c`와 `tcp_client.c`에서는 서버가 한번의 `write` 함수호출을 통해서 전송한 문자열을 여러 차례의 `read` 함수호출을 통해서 읽어들였다. 그럼 이번에는 서버가 여러차례의 `write` 함수호출을 통해서 전송한 문자열을 클라이언트에서 한번의 `read` 함수호출을 통해서 읽어들이는 형태로 예제를 변경해보자. 단, 이를 위해서 클라이언트는 `read` 함수의 호출 시기를 다소 늦출 필요가 있다. 서버가 데이터를 모두 전송할 때까지 기다려야하기 때문이다. 그럼 이를 위해서 리눅스와 윈도우 양쪽 모두에서 다음 유형의 문장을 이용해서 `read` 또는 `recv` 함수의 호출시기를 늦추기로 하자.
```cpp
for (i = 0; i < 3000; i++)
	printf("Wait time %d \n", i);
```
이렇게 CPU에게 불필요한 일을 시켜가면서 실행의 흐름을 지연시키는 것을 가리켜 `Busy Waiting`이라 하는데, 이를 적절히 활용하면 우리에게 필요한 만큼 함수의 호출시기를 늦출 수 있다.    


