---
title:  "Chapter 22 - Overlapped IO 모델"
excerpt: "Part 03"

categories:
  - 열혈 TCP/IP 소켓 프로그래밍
tags:
  - [net, Server]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2023.02.09 10:00:00
---

# Chapter 22 - Overlapped IO 모델

## 22-1 : Overlapped IO 모델의 이해

***

## 22-2 : Overlapped IO에서의 입출력 완료의 확인

***

# 내용 확인문제

1. Asnchronous(비동기) `Notification IO` 모델과 `Overlapped IO` 모델 사이에서 비동기로 처리되는 영역이 어떻게 차이가 나는지 설명해보자.     

<br/>

2. 논-블로킹 IO, 비동기 IO 그리고 `Overlapped IO`의 관계를 하나의 문장으로 연결해서 설명해보자.    

<br/>

3. 다음 코드의 일부를 보면서 문제점이 있다면 어떠한 문제가 있는지 지적해보자. 그리고 이에대한 해결책도 함께 제시해보자.    
```cpp
while (1)
{
	hRecvSock = accept(hLisnSock, (SOCKADDR*)&recvAdr, &recvAdrSz);
	evObj = WSACreateEvent();
	memset(&overlapped, 0, sizeof(overlapped));
	overlapped.hEvent = evObj;
	dataBuf.len = BUF_SIZE;
	dataBuf.buf = buf;
	WSARecv(hRecvSock, &dataBuf, 1, &recvBytes, &flags, &overlapped, NULL);
}
```
참고로, 위의 코드가 완벽하진 않지만 이 코드만 가지고도 충분히 발견할 수 있는 구조적인 문제점이 있다.    

<br/>

4. `WSASend` 함수호출 이후에 IO가 Pending된 상황과 그렇지 않은 상황을 확인하는 방법에 대해서 소스코드 수준에서 설명해보자.

<br/>

5. 쓰레드의 `alertable wait` 상태는 어떠한 상태를 의미하는가? 그리고 쓰레드를 이 상태가 되도록 하는 함수들 중 두가지만 말해보자.