---
title:  "Chapter 05 - TCP 기반 서버 / 클라이언트 2"
excerpt: "Part 01"

categories:
  - 열혈 TCP/IP 소켓 프로그래밍
tags:
  - [net, Server]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2023.01.14 15:00:00
---

# Chapter 05 - TCP 기반 서버 / 클라이언트 2

## 05-1 : 에코 클라이언트의 완벽 구현!

***

## 05-2 : TCP의 이론적인 이야기!

***

## 05-3 : 윈도우 기반으로 구현하기

***
***

# 내용 확인문제

1. TCP 소켓의 연결설정 과정인 Three-way handshaking에 대해서 설명해보자. 특히 총 3회의 데이터 송수신이 이뤄지는데, 각각의 데이터 송수신 과정에서 주고받는 데이터에 포함된 내용이 무엇인지 설명해보자.    

<br/>

2. TCP는 데이터의 전송을 보장하는 프로토콜이다. 그러나 인터넷을 통해서 전송되는 데이터는 소멸될 수 있다. 그렇다면 TCP는 어떠한 원리로 중간에 소멸되는 데이터의 전송까지 보장하는 것인지 ACK와 SEQ를 대상으로 설명해보자.    

<br/>

3. TCP 소켓을 기반으로 `write` 함수와 `read` 함수가 호출되었을 때의 데이터 이동을 입력버퍼와 출력버퍼의 상태와 더불어서 설명해보자.    

<br/>

4. 데이터를 수신할 상대 호스트의 입력버퍼에 남아있는 여유공간이 50byte인 상황에서 `write` 함수호출을 통해서 70byte의 데이터 전송을 요청했을 때, TCP는 어떻게 이를 처리하는지 설명해보자.    

<br/>

5. Chapter 02에서 보인 예제 tcp_server.c(Chapter 01의 hello_server.c)와 tcp_clinet.c에서는 서버가 전송하는 문자열을 클라이언트가 수신하고 끝낸다. 그런데 이번에는 서버와 클라이언트가 한번씩 문자열을 주고받는 형태로 예제를 변경해보자. 단! 데이터의 송수신이 TCP 기반으로 진행된다는 사실을 고려하여 문자열 전송에 앞서 문자열의 길이 정보를 4바이트 정수의 형태로 먼저 전송하기로 하자. 즉, 연결이 된 상태에서 서버와 클라이언트는 다음의 유형으로 데이터를 송수신해야한다. [0006][Hello?]    
그리고 문자열의 전송순서는 상관이 없으며 문자열의 종류도 여러분이 임의로 결정해도 된다. 단, 총 3회 문자열을 주고받아야한다.    

<br/>

6. 파일을 송수신하기 위해 클라이언트와 서버를 구현하되, 다음 순서의 시나리오를 기준으로 구현해보자.    
* 클라이언트는 프로그램의 사용자로부터 전송받을 파일의 이름을 입력받는다.
* 클라이언트는 해당 이름의 파일전송을 서버에게 요청한다.
* 파일이 존재할 경우 서버는 파일을 전송하고, 파일이 존재하지 않을경우 그냥 연결을 종료한다.