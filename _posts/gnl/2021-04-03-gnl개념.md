---
title:  "[gnl] get_next_line 개념"
excerpt: "gnl이란?"

categories:
  - gnl
tags:
  - [42seoul, gnl]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.04.03 20:40:00
---

# get_next_line?
```c
char	*get_next_line(int fd);
```
get_next_line, 이하 gnl은 매개변수 fd로 받아온 숫자에 해당하는 파일 디스크립터의 텍스트에서 개행문자 `\n`으로 구분되는 한 줄의 문자열을 반환하는 함수이다.    
언뜻 보기엔 생각보다 간단할 것 같았으나...

# gnl 과제에 필요한 개념들
1. [파일 디스크립터](#file-descriptor)
2. [read 함수](#read)
3. [메모리 영역](#메모리-영역)
4. [정적 변수]
4. [메모리 누수 체크]

***

## File descriptor?
[간략하게 짚고 넘어간 적이 있다](https://sueshinkr.github.io/libft/ft_putchar_fd/#file-descriptor%EB%9E%80)    
[참고한 블로그 링크](https://code4human.tistory.com/123?category=785474)    
[엄청나게 정리가 잘 되어있는 블로그](https://bigpel66.oopy.io/library/42/inner-circle/3)    
`File descriptor`란 리눅스 / 유닉스 계열 시스템에서 사용되는 개념이다.    
시스템의 프로세스(process)가 파일(file)을 다룰 때, 해당하는 특정 파일에 접근하기 위해 사용되는 추상적인 값이라고 한다. 이 때 유닉스 시스템에서 일컫는 파일이란 일반적인 파일부터 디렉토리, 소켓, 파이프 등 모든 객체들을 말한다.    

fd는 정수 값으로 표시되며, 최댓값은 플랫폼에 따라 다른 `OPEN_MAX`라는 값이다. C에서는 `limits.h`에 정의되어있다.    
기본적으로 프로세스 내의 fd는 중복될 수 없지만, fd는 프로세스 내부에서 사용되는 값이므로 서로 다른 프로세스에서는 같은 fd를 이용할 수 있다.    

### 유닉스의 작동방식
유닉스는 키보드와 모니터를 포함한 모든 것들을 파일로 모델링한다고 한다.    
예를들어, 디스플레이에 데이터를 출력하는 것은 디스플레이를 담당하는 어떤 파일에 데이터를 쓰는 것과 같다. 키보드에서 데이터를 읽어오는 것은 키보드를 담당하는 어떤 파일에서 데이터를 읽어오는 것과 같다.    

### 스트림(Stream)
입력장치인 키보드의 버튼을 입력하면 신호가 컴퓨터로 전송되고, 그 신호를 처리하여 출력장치인 모니터로 보내 화면에 문자가 나타난다.    
그러나 입출력장치는 키보드와 모니터만이 있는 것이 아니다. 프린터, 마우스, 네트워크, 메모리 등등 다양한 장치들이 있고, 프로그램이 각각의 장치에 직접 접근하여 작동하는 것은 상당히 비효율적이다.    
때문에 모든 장치에서 읽고 써지는 데이터들을 일괄적으로 처리하는 중간자 역할로 만들어낸 것이 바로 스트림이다.    
어떤 장치에서건 필요한 데이터들은 모두 입력 스트림으로 모인다. 반대로 장치로 내보내기 위한 데이터들은 모두 출력 스트림으로 모인다. 
* 물리 디스크 상의 파일, 장치들을 통일된 방식으로 다루기 위한 가상적인 개념.    
* 연속된 문자 또는 데이터. 텍스트 스트림 / 바이너리 스트림으로 구분됨.    
* 유닉스에는 미리 연결되어있는 `표준 스트림(standard streams)`이 존재함.

### 표준 스트림

일반적으로 유닉스에서 동작하는 프로그램은 실행시 세 개의 스트림이 자동으로 열리고, 종료시 자동으로 닫힌다.    
C에서는 `stdio.h` 헤더에 정의되어있으며, 스트림도 파일로 취급하여 다뤄지기 때문에 `unistd.h` 헤더 안에 각각의 스트림에 해당하는 fd값이 선언되어있다.    
* stdin : Standard input, 표준 입력. fd = 0.
* stdout : Standard output, 표준 출력. fd = 1.
* stderr : Standard error, 표준 에러출력. fd = 2.

따라서 새롭게 사용되는 파일들은 fd값이 3부터 할당되게 된다.    

### fd의 처리 구조
![image](https://user-images.githubusercontent.com/100945798/162358976-ca126df5-7809-42cc-b481-7d90deee44b5.png)
* fd table : = File Descriptor Table. `file table`을 참조하는 포인터를 보유하고 있는 테이블로, 프로세스 단위로 할당되어있음.
* file table : file status flag, 현재 파일의 offset, `v-node table`을 참조하는 포인터를 보유하고 있는 테이블로, 머신 단위로 할당되어있음. 
* v-node table : i-node, 파일 크기 등 파일 실행을 위한 정보를 보유하고 있는 테이블.
* i-node : 파일을 기술하는 디스크 상의 데이터 구조로, 파일에 대한 중요한 정보가 담겨있음. 각 `i-node`마다 고유 번호가 있어 파일 식별시 사용.    

예를 들어 같은 파일을 두번 열었을 때, 각각 부여된 파일 디스크립터에 따라 서로 다른 `file table`이 생성된다. `file table` 내의 files status flag와 현재 offset은 서로 별도로 다루어지지만, `v-node ptr`은 같은 `v-node table`을 참조하여 동일한 파일 정보를 다루게 된다.    

### fd 변경
fd를 직접적으로 변경할 수 있는 함수는 존재하지 않고, 대신 복사하는 함수를 통해 간접적으로 변경해야한다.    
fd를 변경하는 함수에는 `dup`과 `dup2`가 있으며, `dup` 함수는 현재 사용되지 않는 fd 중 가장 작은 값으로, `dup2`는 사용자가 지정한 fd값으로 복제한다. 이 때 지정한 fd가 이미 사용중이었다면 이미 열려있던 파일을 닫아 fd를 해제한 후 해당 fd값을 할당한다.    

## read?
```c
#include <unistd.h>

    ssize_t read(int fd, void *buf, size_t count)
```

### Linux manpage description    
: read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.    

### 해석 및 부연설명    
: 파일 디스크립터 fd에서 count만큼의 바이트를 읽어 buf에 저장한다.    
이 때 파일은 읽어들인 바이트만큼의 offset 값이 증가하게 되어 다음번 `read`시에는 그 위치부터 파일을 읽게 된다.    
* 정상적으로 작동시 : 읽어들인 바이트 수를 반환    
* 파일의 끝(`EOF`)에 도달했을 경우(= 더이상 읽을 데이터가 없을 경우) : 0 반환    
* 그 외 비정상적인 작동시 : -1 반환, `errno` 설정    

반환값이 ssize_t(주로 signed int)인 이유는 함수의 작동 실패시 -1을 반환하기 위함이다.    

### EOF를 만나는 경우
count만큼의 바이트를 읽어오는 중간에 `EOF`를 만난다면 `read` 함수는 거기서 작동을 멈추고 지금까지 읽은 바이트 수를 반환한다.    
이후에 다시 한번 `read`함수가 실행된다면, offset이 `EOF`에 도달했으므로 0을 반환하게 된다.    

### block / nonblock
`read` 함수는 호출시 기본적으로 blocking된다. 파일에 읽을 데이터가 없는 경우(`EOF`를 만나는 경우와는 다름), `read` 함수는 읽어낼 데이터가 생길 때 까지 block되어 작동을 일시정지 상태로 바꾼다.
```c
char	n[10];
read(0, n, 10);
```
위 코드의 경우 실행된 `read`는 표준 입력에서 10바이트를 받을 때까지 무한정 기다린다.    
기다리지 않고 데이터가 없을 경우 바로 함수를 끝나는 경우가 nonblock이다.    
`read` 함수를 nonblock으로 실행하고 싶다면 애초에 읽어들일 fd를 `open` 함수로 호출할 시 `O_NONBLOCK` 옵션을 사용하면 된다고 한다.    

### errno
`read` 함수가 -1을 반환하면서 설정한 errno는 `error.h`에 정의되어있다.    
따라서 확인시 그냥 `printf("%d", errno)`로 확인해주면 된다고 한다.    
* EAGAIN (=EWOULDBLOCK) : nonblock으로 실행하였으나 읽어올 데이터가 없음
* EBADF : 주어진 파일 디스크립터가 유효하지 않거나 읽기 가능한 모드가 아님
* EFAULT : buf로 전달된 포인터가 호출하는 프로세스의 주소 공간 밖에 존재
* EINTR : 시스템 콜 수행중 인터럽트가 걸려 수행이 중단됨
* EINVAL : 파일 디스크립터가 읽기를 허용하지 않는 객체에 맵핑되어있음
* EIO : 저수준 입출력 에러 발생
* EISDIR : 파일 디스크립터가 디렉토리를 가리킴
	

***

## 메모리 영역

### 프로그램 / 프로세스 / 쓰레드
[참고한 링크](https://velog.io/@gparkkii/ProgramProcessThread)    
* 프로그램(Program)    
명령어들의 집합인 **정적인 상태**의 파일. `Code`와 `Data`로 구분되고, 프로그램 실행시 내부의 명령어들이 작동되며 무언가의 상태를 부여받게 된다.

* 프로세스(Process)    
실행되고있는 **동적인 상태**의 프로그램. 프로세스가 생성되어 메모리가 부여되면 프로그램의 `Code`와 `Data`들이 프로세스 메모리에서 읽히게되며, 이 때 프로세스의 메모리는 `Code Segment`, `Data Segment`, `Heap`, `Stack` 의 독립된 영역을 가진다.    
각 프로세스의 메모리는 서로 독립되어있기 때문에 직접적으로 다른 프로세스에 접근할 수는 없다.    

* 쓰레드(Thread)    
프로세스가 할당받은 자원을 이용하는 기본 실행 단위. 각 쓰레드들은 `Code Segment`, `Data Segment`, `Heap` 메모리 영역을 공유하지만 `Stack`은 독립적으로 가진다. 그렇기 때문에 `Stack` 영역에 선언되는 지역 변수 등은 각 쓰레드마다 별도로 처리된다.    

### Code Segment / Data Segment / Heap / Stack
[참고한 링크](https://blog.naver.com/PostView.nhn?blogId=cjsksk3113&logNo=222270185816)    
![image](https://user-images.githubusercontent.com/100945798/162374858-1c5ae970-82b4-40d1-a0d2-31b60c102988.png)    

* Code Segment(=Text Segment)    
실행가능한 명령어와 코드를 포함한다. 프로세스가 종료될 때까지 유지되며, 프로그램이 이곳의 명령어들을 변경하지 못하도록 읽기 전용인 경우가 많다. 메모리 공간이 덮어씌워지지 않도록 일반적으로 `Heap`과 `Stack` 메모리 공간 아래에 위치한다.    

* Data Segment    
메모리 공간을 효율적으로 사용하기 위해 `Data Segment`와 `BSS Segment`로 구분한다. 이 영역들도 프로세스 종료시까지 유지된다.    
	* Initialized Data Segment : 일반적으로 `Data Segment`라고 부르는 영역으로 초기값이 있는 전역 변수와 정적 변수를 포함한다.    
	초기값을 ROM 메모리에 저장한 후, 데이터들을 활용하기 위해 RAM 메모리로 불러와 사용한다.    
	* Uninitialized Data Segment : `BSS(Block Started by Symbol) Segment`라고 부르는 영역으로 이 영역의 데이터들은 프로그램의 실행과 함께 커널에 의해 0으로 초기화된다. 따라서 굳이 ROM에 저장하지 않고 바로 RAM 메모리로 불러와 사용한다.    
	명시적 초기화가 없는 모든 전역 변수와 정적 변수를 포함하며, `Data Segment`공간의 끝에서 시작된다.    

* Heap    
`BSS Segment`의 끝 주소에서 시작한다. 일반적으로 동적 메모리 할당이 수행되며, `malloc`, `calloc`, `realloc`, `free` 함수를 통해 관리된다.    

* Stack    
지역변수, 메개변수 등이 저장되는 **임시 메모리**로 LIFO(Last in First Out, 후입선출) 구조를 따른다. 
함수 호출시 생성, 함수 종료시 반환되고 일반적으로 메모리 상위 주소에 위치해 `Heap` 영역쪽으로 데이터를 저장해나간다.    
스택 포인터와 힙 포인터가 가리키는 주소가 같아지면 사용가능한 메모리 공간이 전부 소진되었다는 의미이며, 그 이상으로 나아갈 경우 `Heap Overflow`(`Heap` 포인터가 `Stack` 영역을 침범) 또는 `Stack Overflow`(`Stack` 포인터가 `Heap` 영역을 침범)가 발생하게 된다.    
`Stack`의 크기는 시스템에 따라 상이하지만 일반적으로 수십Kb~Mb정도로, 너무 큰 배열이 선언될 경우 `Stack Overflow`문제가 발생할 수 있다. 이때는 `Stack`의 크기를 강제로 늘려주거나 `Stack`이 아닌 다른 메모리를 사용하는 형태의 데이터를 활용하면 된다.


***

# gnl 과제에서 고려해야 하는 점들
아래의 문제점들은 먼저 개념들을 살펴본 후, 실제 구현한 코드를 보면서 해결방법들을 정리해볼 생각이다.

## `read` 함수가 `BUFFER_SIZE`만큼 읽어오기 때문에 생기는 문제    
1. 읽어온 텍스트의 마지막에 정확히 `\n`이 있을 경우    
모든 경우가 이렇다면 아무 걱정 없이 그냥 읽어온 문자열을 그대로 출력하면 그만이다.
2. 읽어온 텍스트 안에 `\n`이 존재하고, 그 뒤로 여분의 문자열이 있을 경우    
먼저 `\n`까지의 한 줄을 반환한 후 `gnl` 함수는 종료된다.    
그 다음번 `gnl` 함수가 호출될 경우에는 방금 전 한줄 반환 후 남아있던 문자열을 반드시 고려하여야 한다.    
3. 읽어온 텍스트 안에 `\n`이 존재하지 않을 경우    
반환할 새로운 줄의 구분 기준은 `\n` 또는 `EOF`이므로, `EOF`가 존재하는 경우가 아니라면 추가로 `read` 함수를 통해 텍스트를 읽어와야한다.    

***

## BUFFER_SIZE에 따라 생기는 문제
1. BUFFER_SIZE가 1이라면?    
한 문자씩 읽어서 `gnl`함수가 원하는대로 작동하도록 할 수 있을까?    
2. BUFFER_SIZE가 99999999라면?    
한번에 파일 디스크립터의 모든 문자를 읽어버린다면 가능할까?    

***

## `read`함수는 매번 읽혀야 할까?
이전 `gnl` 함수 호출 후 남은 문자열에도 `\n`이 있을 때도 read를 하는 것은 비효율적이다.    
그러나 `gnl` 함수에는 `lseek` 함수의 사용이 허용되지 않으므로 이미 읽어들인 파일 디스크립터 속 텍스트의 앞부분으로 이동할 수는 없다.    
따라서 남은 문자열을 따로 저장해둘 필요가 생기고, 이를 위해 정적 변수가 요긴하게 사용될 수 있다.    
