---
title:  "[gnl] get_next_line 개념"
excerpt: "gnl이란?"

categories:
  - gnl
tags:
  - [42seoul, gnl]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.04.03 20:40:00
---

# get_next_line?
```c
char	*get_next_line(int fd);
```
get_next_line, 이하 gnl은 매개변수 fd로 받아온 숫자에 해당하는 파일 디스크립터의 텍스트에서 개행문자 `\n`으로 구분되는 한 줄의 문자열을 반환하는 함수이다.    
언뜻 보기엔 생각보다 간단할 것 같았으나...

# gnl 과제에 필요한 개념들
1. [파일 디스크립터](#file-descriptor)
2. [read 함수](#read)
3. [정적 변수 + 메모리 영역]
4. [메모리 누수 체크]

***

## File descriptor?
[간략하게 짚고 넘어간 적이 있다](https://sueshinkr.github.io/libft/ft_putchar_fd/#file-descriptor%EB%9E%80)    
`File descriptor`란 리눅스 / 유닉스 계열 시스템에서 사용되는 개념이다.    
시스템의 프로세스(process)가 파일(file)을 다룰 때, 해당하는 특정 파일에 접근하기 위해 사용되는 추상적인 값이라고 한다. 이 때 유닉스 시스템에서 일컫는 파일이란 일반적인 파일부터 디렉토리, 소켓, 파이프 등 모든 객체들을 말한다.    
![image](https://user-images.githubusercontent.com/100945798/161950285-771c5ae4-9084-49c6-ac3b-25614595acfa.png)    

fd는 정수 값으로 표시되며, 최댓값은 플랫폼에 따라 다른 `OPEN_MAX`라는 값이다. C에서는 `limits.h`에 정의되어있다.
[참고한 블로그 링크](https://code4human.tistory.com/123?category=785474)    

### 유닉스의 작동방식
유닉스는 키보드와 모니터를 포함한 모든 것들을 파일로 모델링한다고 한다.    
예를들어, 디스플레이에 데이터를 출력하는 것은 디스플레이를 담당하는 어떤 파일에 데이터를 쓰는 것과 같다. 키보드에서 데이터를 읽어오는 것은 키보드를 담당하는 어떤 파일에서 데이터를 읽어오는 것과 같다.    

### 스트림(Stream)
입력장치인 키보드의 버튼을 입력하면 신호가 컴퓨터로 전송되고, 그 신호를 처리하여 출력장치인 모니터로 보내 화면에 문자가 나타난다.    
그러나 입출력장치는 키보드와 모니터만이 있는 것이 아니다. 프린터, 마우스, 네트워크, 메모리 등등 다양한 장치들이 있고, 프로그램이 각각의 장치에 직접 접근하여 작동하는 것은 상당히 비효율적이다.    
때문에 모든 장치에서 읽고 써지는 데이터들을 일괄적으로 처리하는 중간자 역할로 만들어낸 것이 바로 스트림이다.    
어떤 장치에서건 필요한 데이터들은 모두 입력 스트림으로 모인다. 반대로 장치로 내보내기 위한 데이터들은 모두 출력 스트림으로 모인다. 
* 물리 디스크 상의 파일, 장치들을 통일된 방식으로 다루기 위한 가상적인 개념.    
* 연속된 문자 또는 데이터. 텍스트 스트림 / 바이너리 스트림으로 구분됨.    
* 유닉스에는 미리 연결되어있는 `표준 스트림(standard streams)`이 존재함.

### 표준 스트림

일반적으로 유닉스에서 동작하는 프로그램은 실행시 세 개의 스트림이 자동으로 열리고, 종료시 자동으로 닫힌다.    
C에서는 `stdio.h` 헤더에 정의되어있으며, 스트림도 파일로 취급하여 다뤄지기 때문에 `unistd.h` 헤더 안에 각각의 스트림에 해당하는 fd값이 선언되어있다.    
* stdin : Standard input, 표준 입력. fd = 0.
* stdout : Standard output, 표준 출력. fd = 1.
* stderr : Standard error, 표준 에러출력. fd = 2.

따라서 새롭게 사용되는 파일들은 fd값이 3부터 할당되게 된다.    

***

## read?
```c
#include <unistd.h>

    ssize_t read(int fd, void *buf, size_t count)
```

### Linux manpage description    
: read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.    

### 해석 및 부연설명    
: 파일 디스크립터 fd에서 count만큼의 바이트를 읽어 버퍼에 저장한다.    
이 때 파일은 읽어들인 바이트만큼의 offset 값이 증가하게 되어 다음번 `read`시에는 그 위치부터 파일을 읽게 된다.    
* 정상적으로 작동시 : 읽어들인 바이트 수를 반환    
* 파일의 끝(`EOF`)에 도달했을 경우(= 더이상 읽을 데이터가 없을 경우) : 0 반환    
* 그 외 비정상적인 작동시 : -1 반환, `errno` 설정    

### EOF를 만나는 경우
count만큼의 바이트를 읽어오는 중간에 `EOF`를 만난다면 `read` 함수는 거기서 작동을 멈추고 지금까지 읽은 바이트 수를 반환한다.    
이후에 다시 한번 `read`함수가 실행된다면, offset이 `EOF`에 도달했으므로 0을 반환하게 된다.    

### block / nonblock
`read` 함수는 호출시 기본적으로 blocking된다. 파일에 읽을 데이터가 없는 경우(`EOF`를 만나는 경우와는 다름), `read` 함수는 읽어낼 데이터가 생길 때 까지 block되어 작동을 일시정지 상태로 바꾼다.
```c
char	n[10];
read(0, n, 10);
```
위 코드의 경우 실행된 `read`는 표준 입력에서 10바이트를 받을 때까지 무한정 기다린다.    
기다리지 않고 데이터가 없을 경우 바로 함수를 끝나는 경우가 nonblock이다.    
`read` 함수를 nonblock으로 실행하고 싶다면 애초에 읽어들일 fd를 `open` 함수로 호출할 시 `O_NONBLOCK` 옵션을 사용하면 된다고 한다.    

### errno
`read` 함수가 -1을 반환하면서 설정한 errno는 `error.h`에 정의되어있다.    
따라서 확인시 그냥 `printf("%d", errno)`로 확인해주면 된다고 한다.    
* EAGAIN (=EWOULDBLOCK) : nonblock으로 실행하였으나 읽어올 데이터가 없음
* EBADF : 주어진 파일 디스크립터가 유효하지 않거나 읽기 가능한 모드가 아님
* EFAULT : buf로 전달된 포인터가 호출하는 프로세스의 주소 공간 밖에 존재
* EINTR : 시스템 콜 수행중 인터럽트가 걸려 수행이 중단됨
* EINVAL : 파일 디스크립터가 읽기를 허용하지 않는 객체에 맵핑되어있음
* EIO : 저수준 입출력 에러 발생
* EISDIR : 파일 디스크립터가 디렉토리를 가리킴
	

***

# gnl 과제에서 고려해야 하는 점들
아래의 문제점들은 먼저 개념들을 살펴본 후, 실제 구현한 코드를 보면서 해결방법들을 정리해볼 생각이다.

## `read` 함수가 `BUFFER_SIZE`만큼 읽어오기 때문에 생기는 문제    
1. 읽어온 텍스트의 마지막에 정확히 `\n`이 있을 경우    
모든 경우가 이렇다면 아무 걱정 없이 그냥 읽어온 문자열을 그대로 출력하면 그만이다.
2. 읽어온 텍스트 안에 `\n`이 존재하고, 그 뒤로 여분의 문자열이 있을 경우    
먼저 `\n`까지의 한 줄을 반환한 후 `gnl` 함수는 종료된다.    
그 다음번 `gnl` 함수가 호출될 경우에는 방금 전 한줄 반환 후 남아있던 문자열을 반드시 고려하여야 한다.    
3. 읽어온 텍스트 안에 `\n`이 존재하지 않을 경우    
반환할 새로운 줄의 구분 기준은 `\n` 또는 `EOF`이므로, `EOF`가 존재하는 경우가 아니라면 추가로 `read` 함수를 통해 텍스트를 읽어와야한다.    

***

## BUFFER_SIZE에 따라 생기는 문제
1. BUFFER_SIZE가 1이라면?    
한 문자씩 읽어서 `gnl`함수가 원하는대로 작동하도록 할 수 있을까?    
2. BUFFER_SIZE가 99999999라면?    
한번에 파일 디스크립터의 모든 문자를 읽어버린다면 가능할까?    

***

## `read`함수는 매번 읽혀야 할까?
이전 `gnl` 함수 호출 후 남은 문자열에도 `\n`이 있을 때도 read를 하는 것은 비효율적이다.    
그러나 `gnl` 함수에는 `lseek` 함수의 사용이 허용되지 않으므로 이미 읽어들인 파일 디스크립터 속 텍스트의 앞부분으로 이동할 수는 없다.    
따라서 남은 문자열을 따로 저장해둘 필요가 생기고, 이를 위해 정적 변수가 요긴하게 사용될 수 있다.    
