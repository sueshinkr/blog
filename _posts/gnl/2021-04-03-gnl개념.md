---
title:  "[gnl] get_next_line 개념"
excerpt: "gnl이란?"

categories:
  - gnl
tags:
  - [42seoul, gnl]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.04.03 20:40:00
---

# get_next_line?
```c
char	*get_next_line(int fd);
```
get_next_line, 이하 gnl은 매개변수 fd로 받아온 숫자에 해당하는 파일 디스크립터의 텍스트에서 개행문자 `\n`으로 구분되는 한 줄의 문자열을 반환하는 함수이다.    
언뜻 보기엔 생각보다 간단할 것 같았으나 역시나, 그럴 리 없었다.

# gnl 과제에 필요한 개념들
1. 파일 디스크립터
2. read()
3. 정적 변수 + 메모리 영역
4. 메모리 누수 체크

이왕 하는거 개념들을 최대한 정확히 알아가고싶기 때문에 각 항목들에 대해 따로 게시글을 파서 다룰 예정이다.    

# gnl 과제에서 고려해야 하는 점들
아래의 문제점들은 먼저 개념들을 살펴본 후, 실제 구현한 코드를 보면서 해결방법들을 정리해볼 생각이다.
## `read` 함수가 `BUFFER_SIZE`만큼 읽어오기 때문에 생기는 문제    
1. 읽어온 텍스트의 마지막에 정확히 `\n`이 있을 경우    
모든 경우가 이렇다면 아무 걱정 없이 그냥 읽어온 문자열을 그대로 출력하면 그만이다.
2. 읽어온 텍스트 안에 `\n`이 존재하고, 그 뒤로 여분의 문자열이 있을 경우    
먼저 `\n`까지의 한 줄을 반환한 후 `gnl` 함수는 종료된다.    
그 다음번 `gnl` 함수가 호출될 경우에는 방금 전 한줄 반환 후 남아있던 문자열을 반드시 고려하여야 한다.    
3. 읽어온 텍스트 안에 `\n`이 존재하지 않을 경우    
반환할 새로운 줄의 구분 기준은 `\n` 또는 `EOF`이므로, `EOF`가 존재하는 경우가 아니라면 추가로 `read` 함수를 통해 텍스트를 읽어와야한다.    

## BUFFER_SIZE에 따라 생기는 문제
1. BUFFER_SIZE가 1이라면?    
한 문자씩 읽어서 `gnl`함수가 원하는대로 작동하도록 할 수 있을까?    
2. BUFFER_SIZE가 99999999라면?    
한번에 파일 디스크립터의 모든 문자를 읽어버린다면 가능할까?    

## `read`함수는 매번 읽혀야 할까?
이미 이전 `gnl` 함수 호출 후 남은 문자열에도 `\n`이 있다면?    
`gnl` 함수에는 `lseek` 함수의 사용이 허용되지 않으므로 이미 읽어들인 파일 디스크립터 속 텍스트의 앞부분으로 이동할 수는 없다.    
따라서 남은 문자열을 따로 저장해둘 필요가 생기고, 이를 위해 정적 변수가 요긴하게 사용될 수 있다.    
