---
title:  "[libft] Makefile"
excerpt: "Makefile 생성"

categories:
  - libft
tags:
  - [42seoul, libft]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.03.27 13:30:00
---

# Makefile?

[Makefile의 개념과 기초](https://modoocode.com/311)    
[문법 참고](https://wiki.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-3.html)    
Makefile이란 정말 쉽게 이해하자면 컴파일 과정을 간단하고 빠르게 할 수 있도록 도와주는 도구라고 보면 되는 것 같다.    
한번 Makefile을 제대로 만들어두면 일일히 컴파일에 필요한 명령어들을 입력할 필요 없이 Makefile에서 정의된 간단한 명령어만으로 모든 과정을 한번에 처리할 수 있다.    

# Makefile 구현
```c
NAME = libft.a
CC = gcc
CFLAGS = -Wall -Wextra -Werror
AR = ar
HEADER = ./

SRCS = ./ft_isalnum.c ./ft_isalpha.c ./ft_isascii.c\
./ft_isdigit.c ./ft_isprint.c ./ft_strlen.c ./ft_memset.c\
./ft_bzero.c ./ft_memcpy.c ./ft_memmove.c ./ft_strlcpy.c\
./ft_strlcat.c ./ft_strncmp.c ./ft_toupper.c ./ft_tolower.c\
./ft_strchr.c ./ft_strrchr.c ./ft_memchr.c ./ft_memcmp.c\
./ft_strnstr.c ./ft_atoi.c ./ft_calloc.c ./ft_strdup.c\
./ft_substr.c ./ft_strjoin.c ./ft_strtrim.c ./ft_split.c\
./ft_itoa.c ./ft_strmapi.c ./ft_striteri.c ./ft_putchar_fd.c\
./ft_putstr_fd.c ./ft_putendl_fd.c ./ft_putnbr_fd.c\

BONUS_SRCS = ./ft_lstnew.c ./ft_lstadd_front.c ./ft_lstsize.c ./ft_lstlast.c\
./ft_lstadd_back.c ./ft_lstclear.c ./ft_lstdelone.c ./ft_lstiter.c ./ft_lstmap.c

OBJS = $(SRCS:.c=.o)
BONUS_OBJS = $(BONUS_SRCS:.c=.o)

all : $(NAME)

$(NAME) : $(OBJS)
	$(AR) -rcs $(NAME) $^

%.o : %.c
	$(CC) $(CFLAGS) -c $^ -I$(HEADER)

clean :
	rm -f $(OBJS) $(BONUS_OBJS)

fclean : clean
	rm -f $(NAME)

re : fclean all

bonus :
	@make OBJS='$(SRCS:.c=.o) $(BONUS_OBJS)'

.PHONY : all clean fclean re bonus
```
Makefile의 구성 요소는 다음과 같다.    
* 변수 선언
* 타겟과 필요조건
* 명령어
* PHONY

## 변수
크게 사용자 설정 변수와 Makefile에서 제공하는 자동 변수로 나눌 수 있다.    

### 사용자 설정 변수
```c
CC = gcc
CFLAGS = -Wall -Wextra -Werror
```
Makefile에서는 이런 식으로 변수를 정의할 수 있다.    
변수를 사용할 때는 $(변수) 의 형태로 사용하면 된다.    
```c
SRCS = ./ft_isalnum.c ./ft_isalpha.c ./ft_isascii.c\
./ft_isdigit.c ./ft_isprint.c ./ft_strlen.c ./ft_memset.c\ 
...
...
```
위 변수 선언처럼 **\**로 줄바꿈을 할 수도 있다.    

### 자동 변수
`$@`, `$<`, `$^` 등이 있다.
* `$@` : 타겟 이름에 대응된다.    
* `$<` : 의존 파일 목록의 첫번째 파일에 대응된다.    
* `$^` : 의존 파일 목록 전체에 대응된다.    

***

## 타겟(target)
`all`, `clean`, `fclean`, `re`, `bonus`와 같은 것들이다.    
혹은 `$(NAME) : $(OBJS)`의 `$(NAME)`같은 경우에도 해당된다.    
Makefile 실행시 **make 타겟** 의 형태로 입력하면 수행된다.    

### all
Makefile을 실행시키기 위해 다른 옵션 없이 그냥 make 명령어만 입력했을 경우, 해당 명령은 Makefile을 위에서부터 읽으면서 만나는 첫번째 타겟을 실행시킨다.    
따라서 all이라는 더미 타겟을 가장 첫번째 타겟으로 두어 작동하게 하는 것이 일반적이라고 한다.    

### clean
컴파일 과정에서 생성된 오브젝트 파일들을 제거하는 옵션이다.    

### fclean
clean의 기능에 더해, 생성된 라이브러리 파일(.a)도 제거하는 옵션이다.    

### re
fclean의 기능에 더해, 다시 all 옵션을 실행하여 make를 새로 실행한다.

### bonus
libft의 보너스 과제를 풀기 위해 넣은 옵션이다.    
생성할 오브젝트 파일 목록 `OBJS` 변수에 보너스 과제의 함수들도 포함시켜 재지정한다.    

*** 

## 필요조건(prerequisites)
**타겟 : 필요조건** 의 형태로 되어있으며, 쉽게 말해 타겟 실행시 필요한 파일들을 선언해 놓은 것이다. 의존 파일이라고도 한다.    
예를들어 `$(NAME) : $(OBJS)`은 `$(NAME)`타겟의 명령어를 실행시키기 위해 `$(OBJS)`에 해당하는 파일이 필요하다는 것을 뜻한다. 

***

## 명령어(recipes)
타겟 실행시 실제로 어떤 동작을 수행할 것인지를 나타낸 것으로, 타겟 아래 tab 한번의 들여쓰기 이후에 작성된다.    
```c
$(NAME) : $(OBJS)
	$(AR) -rcs $(NAME) $^
```
에서 `$(AR) -rcs $(NAME) $^` 부분이 명령어이다. 

### 명령어가 수행되는 방식
```c
all : $(NAME)

$(NAME) : $(OBJS)
	$(AR) -rcs $(NAME) $^

%.o : %.c
	$(CC) $(CFLAGS) -c $^ -I$(HEADER)
```

***

## PHONY
```c
.PHONY : all clean fclean re bonus
```
위 타겟들을 실행할 때, 만약 해당하는 타겟과 같은 이름을 가진 파일이 디렉토리에 존재한다면 해당 타겟은 정상적으로 실행되지 않는다.    
예를들어 `make clean`을 실행하는데, 이미 디렉토리에 clean이라는 이름의 파일이 존재할 경우 make 명령어는 clean이라는 파일의 유무를 먼저 검사한다.    
이후 clean 파일의 변경점이 없다면 명령을 무시하게 되므로, 지정한 clean 타겟은 실행되지 않는다.    
따라서 **.PHONY**에 해당 타겟들을 등록하여 같은 이름을 가진 파일의 유무와 관계없이 항상 명령에 따른 타겟을 실행하도록 해 안정성을 높일 수 있다.    

***




# 의문점 및 생각해볼점    
1. [잘못된 메모리 접근](#segmentation-fault)

***
