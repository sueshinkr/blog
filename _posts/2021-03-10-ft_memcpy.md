---
title:  "[libft] ft_memcpy"
excerpt: "공부할게 넘쳐난다"

categories:
  - 42seoul
tags:
  - libft
last_modified_at: 2021-03-10T08:06:00-05:00
---

## bzero?

```c
#include <string.h>

       void *memcpy(void *dest, const void *src, size_t n);
```

##### Linux manpage description    
:  The memcpy() function copies n bytes from memory area src to memory area dest. The memory areas must not overlap. Use memmove(3) if the memory areas do overlap.    

##### 내멋대로 해석    
:  src에 저장되어있는 값을 n만큼 복사해 dst의 시작주소부터 붙여넣는다. 각 메모리가 overlap되어있어서는 안되며, 그럴 경우엔 memcpy 대신 memmove를 사용해야한다. 리턴값은 dst의 시작주소.    

##### ex)    
```c
char	str[] = "abckldefghijklmnop";
char	src[] = "12345";
memcpy(str, src, sizeof(src) - 1);
printf("%s\n", str);
```
코드 실행 결과
```c
12345defghijklmnop
````
복사할 src의 맨 마지막에 있을 NULL을 고려하여 size를 설정해야한다.

##### 의문점 및 생각해볼점    
1. overlap?
2. 복사할 size가 dst의 크기를 넘어간다면?
3. strcpy와의 차이점은?

***

## overlap이란

[알기쉽게 정리되어있는 링크](https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=sharonichoya&logNo=220510332768)    
두 변수의 메모리주소가 겹칠 경우 복사 및 붙여넣기시에 덮어씌워지는 현상이 문제가 되는 모양이다. 예를들어    

dst   OOOO12345678    
src   abcd123OOOOO    

이런식으로 존재할경우 src의 값을 dst에 하나씩 복붙하다보면    

dst   OOOOabc45678    
src   abcdabcOOOOO    

이런식으로 아직 복사되지 않은 src의 뒷부분의 값이 원본 src와 달라지게 되어 최종적으로    

dst   OOOOabcdabc8    
src   abcdabcOOOOO    

라는 엉뚱한 결과가 나오게 될 것이다. 그러니까 memcpy 함수에서는 이런 문제가 생길 경우 핸들링할 수 없으니 memmove라는 다른 함수를 써서 처리하라고 한다.    

***

## dst의 크기보다 더 큰 값을 복붙할경우

memcpy 함수 자체에서 그럴 경우를 상정하여 따로 처리하는 기능이 없는지 에러가 발생하거나 엉뚱한 결과가 나왔다.    
얌전히 src의 NULL문자까지 고려한 size를 사용하면 될 것 같다.    

***

## strcpy와의 차이점

strcpy는 애초에 문자열 끝 NULL문자가 나올때까지 복붙하고, memcpy는 복붙할 byte 수를 지정하는 점이 다르니 비교 대상을 strncpy로 잡는게 더 적절해보인다.    
[strncpy와 memcpy의 차이점 링크](https://kldp.org/node/2084)    
둘 다 거의 똑같다고 볼 수 있지만 결과적으로 strncpy는 memcpy와 달리 복사하는 src의 NULL이 언제나오는지를 계속 체크한다는 점이 달랐다.    
n만큼 복사하는 도중에 NULL이 나오면 strncpy는 거기서 끝이고, memcpy는 NULL과 상관없이 딱 정해진 n만큼을 무조건 복사한다.    
그래서 NULL을 꾸준히 확인하는 strncpy보다 memcpy가 좀 더 빠르다고 한다.    

***

# ft_memcpy 구현

```c
void	*ft_memcpy(void *restrict dst, const void *restrict src, size_t size)
{
	void	*start;

	start = dst;
	if (!dst && !src)
		return (0);
	while (size-- > 0)
		*(unsigned char *)dst++ = *(unsigned char *)src++;
	return (start);
}
```
dst와 src 둘 다 NULL일때는 NULL값이 반환된다고 적힌 글들도 있던데, 이걸 어디서 알아내야하는건지 잘 모르겠다. 메뉴얼에는 그런내용 암만봐도 없는데. 이건 나중에 좀 더 알아보고 수정하던가 해야될 것 같다.    
