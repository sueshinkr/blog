---
title:  "[libft] ft_memset"
excerpt: "벌써부터 어렵네"

categories:
  - 42seoul
tags:
  - libft
last_modified_at: 2021-03-09T08:06:00-05:00
---

## memset?

```c
#include <string.h>

       void *memset(void *s, int c, size_t n);
```

##### Linux manpage description    
:  The memset() function fills the first n bytes of the memory area pointed to by s with the constant byte c.    

##### 내멋대로 해석    
:  void형 포인터 s가 가리키고있는 메모리 주소의 처음 위치부터 n바이트만큼에 저장되어있는 값을 상수 c로 채운다..    
그리고 나서 원래 포인터 s(가리키는 주소는 같지만 값은 바뀜) 주소의 처음위치를 리턴하는 함수.    

##### ex)    
```c
char str[] = "abcdefg";
memset(str, '!', 5 * sizeof(char));
printf("%s\n", str):
```
코드 실행 결과
```c
!!!!!efg
````

##### 의문점 및 생각해볼점    
1. void형 포인터에 대해    
2. 변환하는 값이 int형? 4byte씩 들어가는건 아닌것 같은데?    
3. size_t는 뭘까    
4. char *str / char str[]의 차이?

***

## void형 포인터
```c
void *vp;
```
[void형 포인터에 대한 개념을 참조한 링크](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cache798&logNo=130033365299)
void형 포인터에는 모든 포인터 변수를 대입할 수 있다.    
따라서 임의의 대상체에 대해 동작해야 하는 경우에 유용하게 사용될 수 있다.    
반대로 임의의 포인터에 void형 포인터를 대입시에는 형변환을 거쳐야한다. (C++에서는 그래야하지만 C에서는 괜찮다고 함)
```c
ptr = (int *)vp;
```
*연산자 사용시 형변환을 거쳐야한다.
```c
int i = 100;
vp = &i;
*(int *)vp = data;
```
위 코드처럼 int형 변수 i에 대한 주소는 void형 포인터 vp에 바로 대입이 가능하지만, *연산자로 값을 읽을 시에는 형변환이 없다면 어떤 데이터 형식인지 알 수 없기 때문.    
같은 이유로 증감 연산자도 형변환 없이는 사용할 수 없음.    
*과 형변환의 우선 순위는 같으므로 우측 우선 결합에 의해 형변환이 먼저 실행됨.    

즉 void형 포인터는 **단순히 메모리의 한 지점을 가리키는 기능만 가지는 포인터**이다.    

***

## memset 함수의 두번째 매개변수

```c
void *memset(void *s, int c, size_t n);
```
memset이 작동할 때 int형으로 받아온 c값은 실제로 unsigned char형으로 변환되어 사용된다고 한다.    
manpage에 그런 말은 없었던 것 같아 좀 더 자세히 들여다보니, *constant byte c*라고 적혀있긴 했다.    
+++ mac 환경에서의 메뉴얼에는 unsigned char형에 관한 언급이 있었다...
그럼 왜 애초부터 unsigned char형으로 받지 않고 int형으로? 에 대한 의문은 이미 존재했다. [링크](https://stackoverflow.com/questions/5919735/why-does-memset-take-an-int-instead-of-a-char)    
정확히 맞는지는 모르겠지만 memset이 함수 프로토타입이 생기기 이전부터 존재했고, 프로토타입이 없으면 char를 함수에 넣을 수 없었던 것 같다.    
그래서 int형이 쓰였고 그 이후로도 굳이 int대신 char를 넣어서 얻을 이득이 없기에 그대로 쓰고있는 모양이다.    

```c 
int array[100];
memset(array, 1, sizeof(array))
```
unsigned char형으로 변환된다는걸 고려해야 하는 부분이 위와 같은 코드를 사용할 때이다.    
기대한 결과는 00000000 00000000 00000000 00000001 으로 int형의 4바이트 메모리가 각각 채워지는 것이었겠지만, 실제로는 00000001 00000001 00000001 00000001 으로 채워져 전혀 다른 결과가 도출된다.

***

## size_t

```c
typedef unsigned int size_t     // 윈도우
typedef unsigned long size_t    // 리눅스
```
size_t는 이론상 가장 큰 사이즈를 담을 수 있는 unsigned 데이터 타입'으로 정의된다고 한다.    
컴파일러나 운영체제에 따라 그 크기가 달라져 각각의 경우에 size_t가 선언되어있는 타입이 다를 수 있다.

***

## char * / char[] / const char*

[참고한 링크](https://novlog.tistory.com/m/155)    
[참고한 링크2](https://80000coding.oopy.io/1c4da656-b2bf-4cd8-a8fa-8b70befa3e07)
```c
char *s1 = "abc";
char s2[] = "abc";
const char *s3 = "abc";
```
char *s1 = "abc"의 경우 완전히 잘못된 표현.    
생각해보면 포인터 변수를 문자열으로 초기화하는건 애초부터 해선 안되는 행동이었다.    
다만 const char *s3 = "abc"의 경우는 가능. 대신 이 경우 s3이 가리키는 주소값이나, 해당 주소에 저장되어있는 "abc" 값 모두 상수가되어 변경이 불가능하다.    
char s2[] = "abc"의 경우 평범하게 문자열 배열을 초기화하는 방법인 듯 하다. 42과제에서 쓸 수는 없겠지만.    

const char *쪽을 좀 더 자세히 보면    
* const char * = char const * : 가리키는 주소값은 변경 가능, 대상의 값은 변경 불가능    
* char * const : 가리키는 주소값은 변경 불가능, 대상의 값은 변경 가능    
* char const * const = const char * const : 둘 다 변경 불가능    

***

# ft_memset 구현

지금까지의 고민을 토대로 memset 함수를 구현해봤다.

```c
void	*ft_memset(void *ptr, int value, size_t size)
{
	void	*start;

	start = ptr;
	while (size-- > 0)
	{
		*(unsigned char *)ptr = value;
		ptr++;
	}
	return (start);
}
```
