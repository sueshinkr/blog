---
title:  "C++ lecture section2 [2/2]"
excerpt: "데이터 갖고 놀기"

categories:
  - Cpp_lecture
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.09.19 18:00:00
---

# 산술 연산

산술 연산 : 사칙연산, 대입연산 등 
* 대입 : `a = b;`, a에 b를 대입하고 b를 반환 - b의 값을 a에 복사
	값을 반환하기 때문에 `a = b = 3;`같은 형식으로도 사용 가능함
* 사칙연산 : 덧셈 `+`, 뺄셈 `-`, 곱셈 `*`, 나눗셈 `/`, 나머지 `%`   
	* `a = b + 3`, `a += 3` 등의 형태로 사용
	* 증감 연산자 `++`, `--`를 변수의 앞 또는 뒤에 붙여 사용할 수 있으며, 순서에 유의해야함
	* `a += 3`과 `a = a + 3`은 효율에 차이가 없음

`#pragma region`과 `#pragma endregion`으로 특정 영역을 감출 수 있음

***

# 비교 연산과 논리 연산

비교 연산
* `a == b` : a와 b의 값이 같으면 1, 다르면 0을 리턴
* `a != b` : a와 b의 값이 같으면 0, 다르면 1을 리턴
* `a > b` : a가 b보다 크면 1, 아니면 0을 리턴
* `a >= b` : a가 b보다 크거나 같으면 1, 아니면 0을 리턴
* `a < b` : a가 b보다 작으면 1, 아니면 0을 리턴
* `a <= b` : a가 b보다 작거나 같으면 1, 아니면 0을 리턴

어셈블리어로 뜯어보면 비교 연산의 값을 스택에 임시로 저장한 뒤, 그 값을 레지스터에 저장한 후에 변수로 넣는 것을 확인할 수 있음    

논리 연산
* `!` : not을 의미, 1이면 0, 0이면 1을 리턴
* `&&` : and를 의미, 둘 다 1이면 1, 그 외엔 0을 리턴    
	앞 조건이 1이 아닌경우 곧바로 0을 리턴함
* `||` : or를 의미, 둘 중 하나라도 1이면 1, 둘다 0이면 0을 리턴

***

# 비트 연산과 비트 플래그

비트 단위의 조작이 필요할 때가 종종 있음    
대표적으로 `BitFlag`가 사용됨    
* `~` : bitwise not, 단일 숫자의 모든 비트를 대상으로 0은 1, 1은 0으로 뒤바꿈
* `&` : bitwise and, 두 숫자의 모든 비트 쌍을 대상으로 and 연산을 수행
* `|` : bitwise or, 두 숫자의 모든 비트 쌍을 대상으로 or 연산을 수행
* `^` : bitwise xor, 두 숫자의 모든 비트 쌍을 대상으로 xor 연산(두 비트가 다르면 1, 같으면 0)을 수행
* `<<` : 비트 좌측 이동, 비트열을 n만큼 왼쪽으로 이동    
	* 좌측으로 이동하여 범위를 벗어난 비트는 소멸되고, 우측에 새로 생성된 비트들은 0으로 설정됨     
	* 곱하기 2 연산을 할 때 자주 사용됨
* `>>` : 비트 우측 이동, 비트열을 n만큼 오른쪽으로 이동    
	* 우측으로 이동하여 범위를 벗어난 비트는 소멸되고, 좌측에 새로 생성된 비트들은 부호에 따라 달라짐
	* 부호 비트가 존재할 경우 부호 비트를 따라가고, 아니면 0으로 설정됨
	* 따라서 비트 단위의 연산에는 `unsigned` 형이 유용하게 쓰임

```cpp
const int INVINCIBLE = 2;
flag = (1 << 3); // flag = 0b1000, 8
flag |= (1 << INVINCIBLE); // flag = 0b1100
```
비트플래그는 다수의 `boolean`을 선언해야하는 상황에서 쓰일 수 있음    
각 비트마다 상태를 지정하여 사용    

```cpp
bool invincible = ((flag & (1 << 3)) != 0);
bool stunOrinvincible = ((flag & 0b1010) != 0); // (1 << 3) | (1 << 1)과 같은 의미 
```
비트마스크(bitmask)로 각 비트의 상태를 확인

***

# const와 메모리 구조

상수 : 한번 정해지면 절대 바뀌지 않을 값
* constant의 약자인 `const`를 붙여서 변수를 상수화함
* `const` 지정시 반드시 초기값을 설정해야함
* 상수는 일반적으로 모두 대문자로 표기함

메모리 영역은 `stack` / `heap` / `data` / `text` 로 나뉘어짐
* 전역 변수는 데이터 영역에 저장됨
	* 초기값이 있는 경우에는 `.data`, 없는 경우에는 `.bss` 영역에 저장됨
	* `const char * msg = "Hello World"`의 에서의 `msg`의 경우 `.rodata`(읽기 전용 데이터) 영역에 저장됨
* 지역 변수는 스택 영역에 저장됨
* 상수는 어느 영역에 저장하라는 C++ 표준이 존재하지 않음

***

# 유의사항

변수의 유효범위 : 스택에 할당되는 변수의 경우 중괄호의 범위가 생존 범위    
	같은 이름의 변수를 두번 사용할 때 문제가 발생함    

연산 우선순위 : 우선순위가 확실하지 않은 경우는 괄호를 활용할 것    

타입 변환
* 자신보다 작은 크기의 자료형으로 변환할시 데이터의 손실이 발생함    
* 정수를 실수로 변환할시 정밀도 차이로 인한 데이터 손실이 발생    
* `unsinged` 형으로 변환할 시에도 비트 단위로 보면 같은 수이나 분석하는 방법이 달라지기 때문에 주의가 필요    

곱셈의 경우 오버플로우를 주의    
나눗셈의 경우 0으로 나누는 경우와 실수 형식을 주의    
 