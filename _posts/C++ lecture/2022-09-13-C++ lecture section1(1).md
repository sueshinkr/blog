---
title:  "C++ lecture section1 [1/3]"
excerpt: "어셈블리 언어 입문"

categories:
  - Cpp_lecture
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.09.13 15:00:00
---

# 데이터 기초

어셈블러(asembler) : =번역기.    
비트(bit - binary digit) : 0 또는 1의 두가지 값만 가질 수 있는 측정 단위    
바이트(Byte) : 여덟개의 비트로 구성된 데이터의 양을 나타내는 단위    
* 음수를 나타낼 때는 2의 보수를 사용함
* 0x를 붙인 16진수를 유용하게 사용함

8 bit = 1 byte    
16 bit = 2 byte = 1 word    
32 bit = 4 byte = 2 word = 1 dword(double-word)    
64 bit = 8 byte = 4 word = 1 qword(quad-word)    

***

# 레지스터 기초

레지스터 : 데이터를 임시적으로 저장하는 역할    
	CPU 내에 있기 때문에 거리가 짧아 처리속도가 매우 빠름    
* rax = 64비트 / eax = 32비트 / ax = 16비트 / ah, al = 8비트
* `mov 레지스터명, 값` : 레지스터에 값을 저장
* `mov 레지스터1, 레지스터2` : 레지스터2에 저장되어있는 값을 레지스터1에 저장

***

# 변수와 레지스터

`data` 영역에는 초기화 된 데이터를 사용
* `[변수이름] [크기] [초기값]`
* ex) `a db 0x11`, `c dd 0x33333333`
* db = 1, dw = 2, dd = 4, dq = 8 (바이트기준)

`bss` 영역에는 초기화되지 않은 데이터를 사용
* `[변수이름] [크기] [개수]`
* ex) `e resb 10`, `f resq 64`
* resb = 1, resw = 2, resd = 4, resq = 8 (바이트기준)

`data`영역과 `bss`영역이 나뉘어져있는 이유 : 초기화되지 않은 변수는 초기값을 저장할 필요가 없으므로 실행파일의 크기가 작아짐    

`mov 레지스터 변수명`으로 사용시 변수의 주소값이 레지스터에 저장됨    
`mov 레지스터, [변수명]`으로 사용시 변수 자체의 값이 레지스터에 저장됨    
* 단, 크기를 지정하지 않았을시 설정한 레지스터와 같은 크기만큼 읽어들임    
* 원하는 크기만큼 읽고싶을 때는 레지스터 크기를 조절하는 방법을 사용할 수 있음

`move [변수명], 크기지정 값` 또는 `move [변수명], 레지스터명`으로 변수에 값을 지정할 수 있음    
ex) `mov [a], byte 0x55`, `mov [a], word 0x6666`, `mov [a], cl

***

# 문자와 엔디안

문자는 아스키코드를 활용해서 읽음    
동일한 데이터라고 해도 어떻게 분석하고 받아들이냐에 따라 다른 의미가 될 수 있음    

리틀 엔디안 : 대부분 사용, 메모리 주소가 증가함에 따라 변수가 거꾸로 저장됨    
* 캐스팅(데이터의 크기가 큰 자료형에서 작은 자료형으로 바꾸는 것)에 유리

빅 엔디안 : 변수가 메모리 주소 증가에 맞추어 순서대로 저장됨    
* 숫자 비교에 유리

***

# 사칙연산

더하기 : `add a, b`
* a는 레지스터 또는 메모리
* b는 레지스터 또는 메모리 또는 상수
* 단, 메모리를 사용할 때는 `[]`로 주소가 아닌 값을 받아와아하며 a와 b 모두 메모리일 수는 없음
* 메모리에 상수를 더할 때는 더할 상수의 크기를 지정해줘야함

빼기 : `sub a, b`, add와 동일함    

곱하기 : `mul reg`
* 곱해지는 레지스터의 크기에 따라 작동이 달라짐
* `mul bl` = al * bl, 연산 결과는 ax에 저장됨
* `mul bx` = ax * bx, 연산 결과는 상위 16비트가 dx, 하위 16비트가 ax에 저장됨

나누기 : `div reg`
* 나눠지는 레지스터의 크기에 따라 작동이 달라짐
* `div bl` = ax / bl, 연선 결과는 몫이 al에, 나머지가 ah에 저장됨

***

# 시프트 연산과 논리 연산

산술 시프트(shift)에서는 부호를 나타내는 최상위비트는 그대로 유지됨    
`shl 레지스터, 값` 또는 `shr 레지스터, 값`의 형태로 사용    
시프트 연산으로 곱셈 및 나눗셈을 간편하게 할 수 있음    
게임서버에서 ObjectID를 만들 때도 유용하게 사용    

논리 연산에는 `not`, `and`, `or`, `xor`이 있음    
* `not A` : 하나에 조건에 대해 0이면 1, 1이면 0
* `A and B` : 둘다 1이면 1, 나머지는 0
* `A or B` : 둘중 하나라도 1이면 1, 아니면 0
* `A xor B` : 둘다 1이거나 둘다 0이면 0, 아니면 1
* `and al, bl`, `not al` 등의 형태로 사용

비트플래그(bitflag)에 사용    
`xor`을 두번 사용시 원래 값으로 돌아오는 특성이 있으므로 암호학에서 유용하게 사용함    
`xor`을 자기 자신으로 사용시 모든 값이 0으로 대입되기 때문에 오류 체크 등에 사용함    

***

# 분기문

특정 조건에 따라서 코드 흐름을 제어

`cmp dst, src`의 형태로 사용, `dst`가 기준    
비교를 한 결과물은 Flag Register에 저장    
`cmp` 결과에 따라 Flag Register의 각 비트가 경우에 맞게 변환되고, 아래의 `jmp` 등의 연산자들이 그 비트를 참조하여 조건을 판별함

`jmp/je/jne/jg/jge... [label]`의 형태로 이동    
* `jmp` : 무조건 점프
* `je` : JumpEqulas, 같으면 점프
* `jne` : JumpNotEquals, 다르면 점프
* `jg` : JumpGreater, 크면 점프
* `jge` : JumpGreaterEquals, 크거나 같으면 점프
* ...

```assembly
mov ax, 100

mov bl, 2
div bl

cmp ah, 1
je LABEL_ODD
mov rcx, 1
jmp LABEL_EVEN

LABEL_ODD:
	mov rcx, 0
LABEL_EVEN:
	PRINT_HEX 1, rcx
	NEWLINE
```

