---
title:  "C++ Primer 16"
excerpt: "string 클래스와 표준 템플릿 라이브러리"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.10.12 14:00:00
---

# 학습목표
* C++ 표준 `string` 클래스
* `auto_ptr` 템플릿, `unique_ptr` 템플릿, `shared_ptr` 템플릿
* 표준 템플릿 라이브러리(STL)
* 컨테이너 클래스
* 이터레이터(iterator)
* 함수 객체(functor)
* STL 알고리즘
* `initializer_list` 템플릿

***

# 16.1 string 클래스

`string` 클래스는 `string` 헤더 파일을 통해 지원됨    
`string` 클래스에는 문자열 대입, 문자열 결합, 문자열 비교, 개별 문자에 대한 접근, 문자열 안에 있는 문자나 부분 문자열의 검색 등을 포함하는 오버로딩 연산자들, 여러가지 생성자들 및 그 밖의 뭄ㄴ자열 관련 메소드들이 포함되어있음    

## 문자열 생성

`string`이의 생성자에는 여러 종류가 존재
* `string(const char * s)` : 객체를 `s`가 지시하는 NBTS(null-byte-terminated-string)으로 초기화
* `string(size_type n, char c)` : 문자 `c`로 모두 초기화된 원소 n개의 객체 생성
* `string(const string & str)` : 객체를 `string` 객체 `str`로 초기화함(복사 생성자 사용)
* `string()` : 크기가 0인 디폴트 객체 생성
* `string(const char * s, size_type n)` : 객체를 `s`가 지시하는 NBTS로 초기화하되 최대 n개의 문자까지 진행
* `template<class Iter>	string(Iter begin, Iter end)` : 객체를 [begin, end)의 범위에 있는 값들로 초기화, begin과 end는 포인터와 비슷하게 위치를 지정하는 역할을 함
* `string(const string & str, size_type pos, size_type n = npos)` : 객체를 `string` 객체 `str`로 초기화하는데 이 때 `pos`의 위치에서 시작해서 끝까지 가거나 n개의 문자만큼 진행함(단 `str`의 끝을 넘어갈 수는 없음)
* `string(string && str) noexcept` : C++11 이상에서 지원, 객체를 `string` 객체 `str`로 초기화하며 `str`은 바뀔 수 있음
* `string(initializer_list<char> il)` : C++11 이상에서 지원, `string` 객체를 초기자 목록 `il`에 있는 문자로 초기화

```cpp
// str1.cpp

#include <iostream>
#include <string>

int main()
{
	using namespace std;
	string one("Lottery Winner!");
	cout << one << endl;

	string two(20, '$');
	cout << two << endl;
	
	string three(one);
	cout << three << endl;
	
	one += " Oops!";
	cout << one << endl;
	two = "Sorry! That was ";
	three[0] = 'P';
	
	string four;
	four = two + three;
	cout << four << endl;
	
	char alls[] = "All's well that ends well";
	string five(alls, 20);
	cout << five << "!\n";

	string six(alls + 6, alls + 10);
	cout << six << ", ";

	string seven(&five[6], &five[10]);
	cout << seven << "...\n";

	string eight (four, 7, 16);
	cout << eight << "in motion!" << endl;
	return 0;
}
```

오버로딩 연산자 `+` 사용시 임시 `string` 객체가 생성됨    
배열의 이름과는 달리 객체의 이름은 객체의 주소로 간주되지 않기 때문에 `string seven(five + 6, five + 10);`과 같은 형태의 구문은 동작하지 않음    

***

## string 클래스 입력

C 스타일 문자열의 경우
* `cin >> info;` : 한 단어 읽음
* `cin.getline(info, 100);` : 한 행을 읽고 `\n`은 버림
* `cin.getline(info, 100, ':');` : `:`까지 읽고 `:`은 버림
* `cin.get(info. 100);` : 한 행을 읽고 `\n`을 큐에 남겨둠

`string` 객체의 경우
* `cin >> stuff;` : 한 단어를 읽음
* `getline(cin stuff);` : 한 행을 읽고 `\n`은 버림
* `getline(stuff, ':')` : `:`까지 읽고 `:`은 버림

`string` 객체는 입력 문자에 따라 객체의 크기가 자동으로 조절됨    
따라서 `getline()`의 `string` 버전은 입력 문자들의 개수를 제한하는 수치 매개변수를 생략할 수 있음    
`string::npos`가 문자열의 최대 허용 크기이며, 이는 일반적으로 `unsigned int`의 최대 크기임    
`getline()`은 C 스타일 문자열 입력 버전에서는 `istream` 클래스의 메소드이기 때문에 `cin`을 호출 객체로 받고, `string` 버전에서는 독립형 함수이기 때문에 `cin`을 함수 매개변수로 받음


`string` 클래스를 위한 `getline()` 함수는 세가지 조건 중 하나가 발생할때까지 문자를 읽어 문자열로 저장함
* 파일의 끝을 만났을 때 : 입력스트림의 `eofbit`가 설정되며 `fail()`과 `eof()` 메소드가 `true`를 리턴함
* 구분 문자(디폴트는 `\n`)에 도달했을 때 : 구분 문자는 입력스트림으로부터 제거되고 저장되지 않음
* 가능한 최대 문자 수(`string::npos` 혹은 대입에 사용할 수 있는 메모리의 바이트 수 중 더 적은 것)를 읽었을 때 : 입력 스트림의 `failbit`가 설정되며 `fail()` 메소드가 `true`를 리턴함

`string` 클래스를 위한 `operator>>()` 함수는 구분 문자가 아닌 화이트스페이스 문자까지 읽고 그 문자를 입력 큐에 남겨둠    
이 때 화이트스페이스랑 `isspace()` 함수가 `true`를 리턴하는 모든 문자에 해당함    

***

## 문자열 작업

`length()`와 `size()` 멤버는 모두 어떤 문자열에 들어있는 문자 수를 리턴함    
`length()` 메소드는 `string` 클래스의 오래된 버전부터 사용해왔으며, `size()` 메소드는 STL 호환성을 위해 추가됨    

`string` 클래스의 `find` 메소드는 여러가지 변형이 있음
* `size_type find(const string & str, size_type pos = 0) const` : 호출한 문자열의 `pos` 위치에서부터 시작하여 처음으로 발생하는 부분 문자열 `str`을 검색, 발견시 첫 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함
* `size_type find(const char * s, size_type pos = 0) const` : 호출한 문자열의 `pos` 위치에서부터 시작해 처음으로 발생하는 부분 문자열 `s`를 검색, 발견시 첫 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함
* `size_type find(const char * s, size_type pos = 0, size_type n) const` : 호출한 문자열의 `pos` 위치에서부터 시작해 `s`에 있는 처음 n개의 문자로 구성되는 부분 문자열이 처음 나오는 것을 검색, 발견시 첫 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함
* `size_type find(char ch, size_type pos = 0) const` : 호출한 문자열의 `pos` 위치에서부터 시작해 문자 `ch`가 처음 나오는 것을 검색, 발견시 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함

`string` 라이브러리는 그 외에도 관련된 메소드들을 제공
* `rfind()` : 가장 마지막으로 발생하는 부분 문자열 또는 문자를 검색
* `find_first_of()` : 호출한 문자열에서 매개변수에 있는 문자들 중 가장 먼저 발생하는 문자를 검색
* `find_last_of()` : 호출한 문자열에서 매개변수에 있는 문자들 중 가장 마지막에 발생하는 문자를 찾음
* `find_first_not_of()` : 호출한 문자열에서 매개변수에 없는 첫 문자를 검색
* `find_last_not_of()` : 호출한 문자열에서 매개변수에 없는 가장 마지막 문자를 검색

```cpp
// hangman.cpp

#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
using std::string;

const int NUM = 26;
const string wordlist[NUM] = {"apiary", "beetle", "cereal",
	"danger", "ensign", "florid", "garage", "health", "insult",
	"jackal", "keeper", "loaner", "manage", "nonce", "onset",
	"plaid", "quilt", "remote", "stolid", "train", "useful",
	"valid", "whence", "xenon", "yearn", "zippy"};

int main()
{
	using std::cout;
	using std::cin;
	using std::tolower;
	using std::endl;
	std::srand(std::time(0));
	char play;
	cout << "영어 단어 게임을 하시겠습니까? <y/n> ";
	cin >> play;
	play = tolower(play);
	while (play == 'y')
	{
		string target = wordlist[std::rand() % NUM];
		int length = target.length();
		string attempt(length, '-');
		string badchars;
		int guesses = 6;
		cout << "수수께끼 단어를 추측해 보십시오.\n"
			 << length << "개의 문자로 이루어져있습니다.\n"
			 << "한 번에 한 문자씩 추측하십시오.\n"
			 << "틀릴 수 있는 기회 : " << guesses << "번\n";
		cout << "추측하는 단어 : " << attempt << endl;
		while (guesses > 0 && attempt != target)
		{
			char letter;
			cout << "문자를 추측하십시오 : ";
			cin >> letter;
			if (badchars.find(letter) != string::npos
				|| attempt.find(letter) != string::npos)
			{
				cout << "이미 추측한 문자입니다. 다시 하십시오. \n";
				continue;
			}
			int loc = target.find(letter);
			if (loc == string::npos)
			{
				cout << "땡! 틀렸습니다.\n";
				--guesses;
				badchars += letter;
			}
			else
			{
				cout << "딩동댕! 맞았습니다. \n";
				attempt[loc] = letter;
				loc = target.find(letter, loc + 1);
				while (loc != string::npos)
				{
					attempt[loc] = letter;
					loc = target.find(letter, loc + 1);
				}
			}
			cout << "추측하는 단어 : " << attempt << endl;
			if (attempt != target)
			{
				if (badchars.length() > 0)
					cout << "틀리게 추측한 문자들 : " << badchars << endl;
				cout << "틀릴 수 있는 기회 : " << guesses << "번\n";
			}
		}
		if (guesses > 0)
			cout << "그렇습니다. 그것이 수수께끼 단어입니다.\n";
		else
			cout << "안타깝습니다. 수수께끼 단어는 " << target << "입니다.\n";
		cout << "게임을 다시 하시겠습니까? <y/n> ";
		cin >> play;
		play = tolower(play);
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}
```

***

## string 클래스가 제공하는 그 밖의 기능

```cpp
// str2.cpp

//#include "xxx.h"
#include <iostream>
#include <string>

int main()
{
	using namespace std;
	string empty;
	string small = "bit";
	string larger = "Elephants are a girl's mest friend";
	
	cout << "크기 : \n";
	cout << "\tempty : " << empty.size() << endl;
	cout << "\tsmall : " << small.size() << endl;
	cout << "\tlarger : " << larger.size() << endl;
	
	cout << "용량 : \n";
	cout << "\tempty : " << empty.capacity() << endl;
	cout << "\tsmall : " << small.capacity() << endl;
	cout << "\tlarger : " << larger.capacity() << endl;
	
	empty.reserve(50);
	cout << "empty.reserve(50) 이후 용량 : "
		 << empty.capacity() << endl;
	return 0;
}
```

하나의 문자를 문자열에 추가할 때, 이웃 메모리가 이미 사용중일 가능성이 있으므로 해당 문자열의 메모리 바로 뒤에 이어서 저장할 수는 없음    
따라서 새로은 블록을 대입하고 이전의 내용을 새로운 위치로 복사해야 하는데, 여기서 발생하는 비효율을 막기위해 C++ 시스템들은 실제 문자열보다 훨씬 큰 메모리 블록을 대입하여 문자열이 추가될 수 있는 공간을 제공함    
추가된 문자열이 그 크기마저 초과할시 프로그램은 두 배 크기의 새로운 블록을 대입하여 연속적인 크기조절 없이 문자열이 늘어날 수 있도록 더 많은 공간을 제공함    

`capacity()` : 현재 블록의 크기를 리턴    
`reserve()` : 그 블록을 위한 최소 크기를 사용자가 요청하게함    

`open()` 메소드가 매개변수로 C 스타일 문자열을 요구하기 때문에 `c_str()` 메소드를 사용하여 `string` 객체와 동일한 내용을 가지는 C 스타열 문자열을 가리키는 포인터를 리턴할 수 있음    

***

## string 다양성

실제 문자열 라이브러리는 아래 템플릿 클래스에 기초하고있음    
```cpp
template <class charT, class traits = char _traits<charT>,
		  class Allocator = allocator<charT>>
basic_string {...};

typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
```
클래스에 위와 같은 `typedef`들이 들어있기 때문에 `char`형 뿐만 아니라 여러 형태의 문자열도 사용할 수 있음    
`traits` 클래스는 값을 비교하는 방법 등의 해당 문자혀에 관한 고유의 특징을 서술함    
`Allocator` 클래스는 메모리를 관리하기 위해 사용되며, `new`와 `delete`를 통상적인 방법으로 사용함    


***
***


# 16.2 스마트 포인터 템플릿 클래스

