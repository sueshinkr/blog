---
title:  "C++ Primer 16"
excerpt: "string 클래스와 표준 템플릿 라이브러리"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.10.12 14:00:00
---

# 학습목표
* C++ 표준 `string` 클래스
* `auto_ptr` 템플릿, `unique_ptr` 템플릿, `shared_ptr` 템플릿
* 표준 템플릿 라이브러리(STL)
* 컨테이너 클래스
* 이터레이터(iterator)
* 함수 객체(functor)
* STL 알고리즘
* `initializer_list` 템플릿

***

# 16.1 string 클래스

`string` 클래스는 `string` 헤더 파일을 통해 지원됨    
`string` 클래스에는 문자열 대입, 문자열 결합, 문자열 비교, 개별 문자에 대한 접근, 문자열 안에 있는 문자나 부분 문자열의 검색 등을 포함하는 오버로딩 연산자들, 여러가지 생성자들 및 그 밖의 뭄ㄴ자열 관련 메소드들이 포함되어있음    

## 문자열 생성

`string`이의 생성자에는 여러 종류가 존재
* `string(const char * s)` : 객체를 `s`가 지시하는 NBTS(null-byte-terminated-string)으로 초기화
* `string(size_type n, char c)` : 문자 `c`로 모두 초기화된 원소 n개의 객체 생성
* `string(const string & str)` : 객체를 `string` 객체 `str`로 초기화함(복사 생성자 사용)
* `string()` : 크기가 0인 디폴트 객체 생성
* `string(const char * s, size_type n)` : 객체를 `s`가 지시하는 NBTS로 초기화하되 최대 n개의 문자까지 진행
* `template<class Iter>	string(Iter begin, Iter end)` : 객체를 [begin, end)의 범위에 있는 값들로 초기화, begin과 end는 포인터와 비슷하게 위치를 지정하는 역할을 함
* `string(const string & str, size_type pos, size_type n = npos)` : 객체를 `string` 객체 `str`로 초기화하는데 이 때 `pos`의 위치에서 시작해서 끝까지 가거나 n개의 문자만큼 진행함(단 `str`의 끝을 넘어갈 수는 없음)
* `string(string && str) noexcept` : C++11 이상에서 지원, 객체를 `string` 객체 `str`로 초기화하며 `str`은 바뀔 수 있음
* `string(initializer_list<char> il)` : C++11 이상에서 지원, `string` 객체를 초기자 목록 `il`에 있는 문자로 초기화

```cpp
// str1.cpp

#include <iostream>
#include <string>

int main()
{
	using namespace std;
	string one("Lottery Winner!");
	cout << one << endl;

	string two(20, '$');
	cout << two << endl;
	
	string three(one);
	cout << three << endl;
	
	one += " Oops!";
	cout << one << endl;
	two = "Sorry! That was ";
	three[0] = 'P';
	
	string four;
	four = two + three;
	cout << four << endl;
	
	char alls[] = "All's well that ends well";
	string five(alls, 20);
	cout << five << "!\n";

	string six(alls + 6, alls + 10);
	cout << six << ", ";

	string seven(&five[6], &five[10]);
	cout << seven << "...\n";

	string eight (four, 7, 16);
	cout << eight << "in motion!" << endl;
	return 0;
}
```

오버로딩 연산자 `+` 사용시 임시 `string` 객체가 생성됨    
배열의 이름과는 달리 객체의 이름은 객체의 주소로 간주되지 않기 때문에 `string seven(five + 6, five + 10);`과 같은 형태의 구문은 동작하지 않음    

***

## string 클래스 입력

C 스타일 문자열의 경우
* `cin >> info;` : 한 단어 읽음
* `cin.getline(info, 100);` : 한 행을 읽고 `\n`은 버림
* `cin.getline(info, 100, ':');` : `:`까지 읽고 `:`은 버림
* `cin.get(info. 100);` : 한 행을 읽고 `\n`을 큐에 남겨둠

`string` 객체의 경우
* `cin >> stuff;` : 한 단어를 읽음
* `getline(cin stuff);` : 한 행을 읽고 `\n`은 버림
* `getline(stuff, ':')` : `:`까지 읽고 `:`은 버림

`string` 객체는 입력 문자에 따라 객체의 크기가 자동으로 조절됨    
따라서 `getline()`의 `string` 버전은 입력 문자들의 개수를 제한하는 수치 매개변수를 생략할 수 있음    
`string::npos`가 문자열의 최대 허용 크기이며, 이는 일반적으로 `unsigned int`의 최대 크기임    
`getline()`은 C 스타일 문자열 입력 버전에서는 `istream` 클래스의 메소드이기 때문에 `cin`을 호출 객체로 받고, `string` 버전에서는 독립형 함수이기 때문에 `cin`을 함수 매개변수로 받음


`string` 클래스를 위한 `getline()` 함수는 세가지 조건 중 하나가 발생할때까지 문자를 읽어 문자열로 저장함
* 파일의 끝을 만났을 때 : 입력스트림의 `eofbit`가 설정되며 `fail()`과 `eof()` 메소드가 `true`를 리턴함
* 구분 문자(디폴트는 `\n`)에 도달했을 때 : 구분 문자는 입력스트림으로부터 제거되고 저장되지 않음
* 가능한 최대 문자 수(`string::npos` 혹은 대입에 사용할 수 있는 메모리의 바이트 수 중 더 적은 것)를 읽었을 때 : 입력 스트림의 `failbit`가 설정되며 `fail()` 메소드가 `true`를 리턴함

`string` 클래스를 위한 `operator>>()` 함수는 구분 문자가 아닌 화이트스페이스 문자까지 읽고 그 문자를 입력 큐에 남겨둠    
이 때 화이트스페이스랑 `isspace()` 함수가 `true`를 리턴하는 모든 문자에 해당함    

***

## 문자열 작업

`length()`와 `size()` 멤버는 모두 어떤 문자열에 들어있는 문자 수를 리턴함    
`length()` 메소드는 `string` 클래스의 오래된 버전부터 사용해왔으며, `size()` 메소드는 STL 호환성을 위해 추가됨    

`string` 클래스의 `find` 메소드는 여러가지 변형이 있음
* `size_type find(const string & str, size_type pos = 0) const` : 호출한 문자열의 `pos` 위치에서부터 시작하여 처음으로 발생하는 부분 문자열 `str`을 검색, 발견시 첫 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함
* `size_type find(const char * s, size_type pos = 0) const` : 호출한 문자열의 `pos` 위치에서부터 시작해 처음으로 발생하는 부분 문자열 `s`를 검색, 발견시 첫 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함
* `size_type find(const char * s, size_type pos = 0, size_type n) const` : 호출한 문자열의 `pos` 위치에서부터 시작해 `s`에 있는 처음 n개의 문자로 구성되는 부분 문자열이 처음 나오는 것을 검색, 발견시 첫 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함
* `size_type find(char ch, size_type pos = 0) const` : 호출한 문자열의 `pos` 위치에서부터 시작해 문자 `ch`가 처음 나오는 것을 검색, 발견시 문자의 인덱스를 리턴하며 찾지 못한 경우 `string::npos`를 리턴함

`string` 라이브러리는 그 외에도 관련된 메소드들을 제공
* `rfind()` : 가장 마지막으로 발생하는 부분 문자열 또는 문자를 검색
* `find_first_of()` : 호출한 문자열에서 매개변수에 있는 문자들 중 가장 먼저 발생하는 문자를 검색
* `find_last_of()` : 호출한 문자열에서 매개변수에 있는 문자들 중 가장 마지막에 발생하는 문자를 찾음
* `find_first_not_of()` : 호출한 문자열에서 매개변수에 없는 첫 문자를 검색
* `find_last_not_of()` : 호출한 문자열에서 매개변수에 없는 가장 마지막 문자를 검색

```cpp
// hangman.cpp

#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
using std::string;

const int NUM = 26;
const string wordlist[NUM] = {"apiary", "beetle", "cereal",
	"danger", "ensign", "florid", "garage", "health", "insult",
	"jackal", "keeper", "loaner", "manage", "nonce", "onset",
	"plaid", "quilt", "remote", "stolid", "train", "useful",
	"valid", "whence", "xenon", "yearn", "zippy"};

int main()
{
	using std::cout;
	using std::cin;
	using std::tolower;
	using std::endl;
	std::srand(std::time(0));
	char play;
	cout << "영어 단어 게임을 하시겠습니까? <y/n> ";
	cin >> play;
	play = tolower(play);
	while (play == 'y')
	{
		string target = wordlist[std::rand() % NUM];
		int length = target.length();
		string attempt(length, '-');
		string badchars;
		int guesses = 6;
		cout << "수수께끼 단어를 추측해 보십시오.\n"
			 << length << "개의 문자로 이루어져있습니다.\n"
			 << "한 번에 한 문자씩 추측하십시오.\n"
			 << "틀릴 수 있는 기회 : " << guesses << "번\n";
		cout << "추측하는 단어 : " << attempt << endl;
		while (guesses > 0 && attempt != target)
		{
			char letter;
			cout << "문자를 추측하십시오 : ";
			cin >> letter;
			if (badchars.find(letter) != string::npos
				|| attempt.find(letter) != string::npos)
			{
				cout << "이미 추측한 문자입니다. 다시 하십시오. \n";
				continue;
			}
			int loc = target.find(letter);
			if (loc == string::npos)
			{
				cout << "땡! 틀렸습니다.\n";
				--guesses;
				badchars += letter;
			}
			else
			{
				cout << "딩동댕! 맞았습니다. \n";
				attempt[loc] = letter;
				loc = target.find(letter, loc + 1);
				while (loc != string::npos)
				{
					attempt[loc] = letter;
					loc = target.find(letter, loc + 1);
				}
			}
			cout << "추측하는 단어 : " << attempt << endl;
			if (attempt != target)
			{
				if (badchars.length() > 0)
					cout << "틀리게 추측한 문자들 : " << badchars << endl;
				cout << "틀릴 수 있는 기회 : " << guesses << "번\n";
			}
		}
		if (guesses > 0)
			cout << "그렇습니다. 그것이 수수께끼 단어입니다.\n";
		else
			cout << "안타깝습니다. 수수께끼 단어는 " << target << "입니다.\n";
		cout << "게임을 다시 하시겠습니까? <y/n> ";
		cin >> play;
		play = tolower(play);
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}
```

***

## string 클래스가 제공하는 그 밖의 기능

```cpp
// str2.cpp

//#include "xxx.h"
#include <iostream>
#include <string>

int main()
{
	using namespace std;
	string empty;
	string small = "bit";
	string larger = "Elephants are a girl's mest friend";
	
	cout << "크기 : \n";
	cout << "\tempty : " << empty.size() << endl;
	cout << "\tsmall : " << small.size() << endl;
	cout << "\tlarger : " << larger.size() << endl;
	
	cout << "용량 : \n";
	cout << "\tempty : " << empty.capacity() << endl;
	cout << "\tsmall : " << small.capacity() << endl;
	cout << "\tlarger : " << larger.capacity() << endl;
	
	empty.reserve(50);
	cout << "empty.reserve(50) 이후 용량 : "
		 << empty.capacity() << endl;
	return 0;
}
```

하나의 문자를 문자열에 추가할 때, 이웃 메모리가 이미 사용중일 가능성이 있으므로 해당 문자열의 메모리 바로 뒤에 이어서 저장할 수는 없음    
따라서 새로은 블록을 대입하고 이전의 내용을 새로운 위치로 복사해야 하는데, 여기서 발생하는 비효율을 막기위해 C++ 시스템들은 실제 문자열보다 훨씬 큰 메모리 블록을 대입하여 문자열이 추가될 수 있는 공간을 제공함    
추가된 문자열이 그 크기마저 초과할시 프로그램은 두 배 크기의 새로운 블록을 대입하여 연속적인 크기조절 없이 문자열이 늘어날 수 있도록 더 많은 공간을 제공함    

`capacity()` : 현재 블록의 크기를 리턴    
`reserve()` : 그 블록을 위한 최소 크기를 사용자가 요청하게함    

`open()` 메소드가 매개변수로 C 스타일 문자열을 요구하기 때문에 `c_str()` 메소드를 사용하여 `string` 객체와 동일한 내용을 가지는 C 스타열 문자열을 가리키는 포인터를 리턴할 수 있음    

***

## string 다양성

실제 문자열 라이브러리는 아래 템플릿 클래스에 기초하고있음    
```cpp
template <class charT, class traits = char _traits<charT>,
		  class Allocator = allocator<charT>>
basic_string {...};

typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
```
클래스에 위와 같은 `typedef`들이 들어있기 때문에 `char`형 뿐만 아니라 여러 형태의 문자열도 사용할 수 있음    
`traits` 클래스는 값을 비교하는 방법 등의 해당 문자혀에 관한 고유의 특징을 서술함    
`Allocator` 클래스는 메모리를 관리하기 위해 사용되며, `new`와 `delete`를 통상적인 방법으로 사용함    


***
***


# 16.2 스마트 포인터 템플릿 클래스

스마트 포인터는 포인터처럼 행동하는 클래스 객체로, 몇 가지 추가 기능을 지님    
일반 포인터와 달리 수명이 다했을 때 스마트 포인터가 지시하는 메모리도 파괴자를 통해서 함께 해제할 수 있음    

## 스마트 포인터의 사용

스마트 포인터를 사용하기 위해서는 템플릿을 정의하는 `memory` 헤더 파일을 소스 코드에 포함해야함    

```cpp
// smrtptrs.cpp

#include <iostream>
#include <string>
#include <memory>

class Report
{
	private:
		std::string str;
	public:
		Report(const std::string s) : str(s)
			{ std::cout << "객체가 생성되었습니다!\n"; }
		~Report() { std::cout << "객체가 삭제되었습니다!\n"; }
		void comment() const { std::cout << str << "\n"; }
};

int main()
{
	{
		std::auto_ptr<Report> ps (new Report("auto_ptr"));
		ps->comment();
	}
	{
		std::shared_ptr<Report> ps (new Report("shared_ptr"));
		ps->comment();
	}
	{
		std::unique_ptr<Report> ps (new Report("unique_ptr"));
		ps->comment();
	}
	return 0;
}
```

스마트 포인터 템플릿의 클래스들은 명시적 생성자를 가지고있음    
따라서 암시적 변환은 허용되지 않으며, 포인터를 변환하기 위한 자동 형 변환은 없어도 됨    
스마트 포인터 템플릿 클래스들은 일반 포인터처럼 동작하기 때문에 같은 타입의 포인터를 가리키기 위해 일반 포인터를 대입할 수 있으나 문제가 생길 수 있음    

***

## 스마트 포인터 고려사항

```cpp
auto_ptr<string> ps (new string("I reigned ..."));
auto_ptr<string> vocation;
vocation = ps;
```

위 코드는 같은 객체에 대해 두번 해제를 시도하기 때문에 허용되지 않음
* 복사를 수행하도록 대입 연산자를 정의하여 두 포인터가 서로 다른 객체를 지시하도록 만들어 해결
* 하나의 스마트 포인터만이 특정 객체를 소유할 수 있도록 소유권 개념을 도입하여 해결 - `auto_ptr`, `unique_ptr`에서 사용
* 하나의 특정한 객체를 참조하는 스마트 포인터들이 몇 개인지 추적하는 스마트 포인터를 생성하여 해결하며, 이를 참조 카운팅(reference counting)이라고 함 - `shared_ptr`에서 사용

```cpp
// fowl.cpp

#include <iostream>
#include <string>
#include <memory>

int main()
{
	using namespace std;
	auto_ptr<string> films[5] = 
	{
		auto_ptr<string> (new string("Fowl Balls")),
		auto_ptr<string> (new string("Duck Walks")),
		auto_ptr<string> (new string("Chicken RUns")),
		auto_ptr<string> (new string("Turkey Errors")),
		auto_ptr<string> (new string("Goose Eggs"))
	};
	auto_ptr<string> pwin;
	pwin = films[2];

	cout << "다음은 최고의 조류 영화상 후보입니다\n";
	for (int i = 0; i < 5; i++)
		cout << *films[i] << endl;
	cout << "수상자는 " << *pwin << "!\n";
	cin.get();
	return 0;
}
```

`pwin = films[2];` 구문으로 인해 `film[2]`가 객체에 대한 소유권을 포기하고, 더이상 해당 객체에 접근하지 않음    
따라서 이후에 `films[2]`가 가리키는 문자열을 출력시 문제가 발생함    
`unique_ptr` 사용시에는 `pwin = films[2];`에서 컴파일 오류가 발생함    
그러나 `auto_ptr`이 아닌 `shared_ptr`을 쓰면 정상적으로 출력됨
* `pwin`과 `films[2]`가 같은 객체를 가리키며 참조 카운트가 올라감
* `pwin`의 파괴자가 참조 카운트를 줄이고, `shared_ptr`의 배열 멤버들이 해제되며 `films[2]`의 파괴자로 인해 참조 카운트가 0이되어 메모리가 해제됨

***

## auto_ptr보다 unique_ptr이 더 좋은 이유

```cpp
auto_ptr<string> p1(new string("auto")); // #1
auto_ptr<string> p2; // #2
p2 = p1; // #4
```

#3에서 p2가 문자열 객체에 대한 소유권 인수시 p1은 소유권을 상실하고, 이로 인해 p1과 p2의 파괴자가 동일한 객체에 대한 메모리를 해제하는 것을 방지함    
단, p1이 유효한 값을 가지지 않기 때문에 문제가 발생함    

```cpp
unique_ptr<string> p3(new string("auto")); // #4
unique_ptr<string> p4; // #5
p4 = p3; // #6
```

이 경우에는 #6에서 컴파일 에러가 발생함    
따라서 `unique_ptr`이 `auto_ptr`보다 더 안전함    

```cpp
unique_ptr<string> demo(const char * s)
{
	unique_ptr<string> temp(new string(s));
	return temp;
}

unique_ptr<string> ps;
ps = demo("Uniquely special");
```

스마트 포인터를 다른 스마트 포인터에 대입시 타이밍이 맞지 않는 문제가 발생할 수 있음    
따라서 위와 같이 함수를 정의할 경우 `demo()` 함수에서 임시 `unique_ptr`를 리턴하기 때문에 문제가 발생하지 않음
* `ps`가 `unique_ptr`이 리턴한 객체의 소유권을 얻음
* 리턴된 `unique_ptr`은 삭제됨
* `demo()`가 리턴한 `unique_ptr`은 임시이므로 유효하지 않은 값에 접근할 가능성이 없어 금지된 대입이 발생하지 않음

하나의 `unique_ptr`에서 다른 `unique_ptr`에 대입을 시도할시 원본 객체가 중복되어있다면 시도가 허용되지 않음    
이와같은 선택적 행동으로 인해 `unique_ptr`가 `auto_ptr`보다 우수하며, 따라서 `auto_ptr`은 C++17이후 사용이 금지됨    

```cpp
unique_ptr<string> ps1, ps2;
ps1 = demo("Uniquely special");
ps2 = move(ps1);
```

`unique_ptr`을 다른 `unique_ptr`로 대입할 수 있는 `std::move()` 표준 라이브러리 함수가 존재함    
`unique_ptr`은 배열으로도 사용될 수 있기 때문에 `new`와 `new[]`, `delete`와 `delete[]`를 모두 가지고있음    

***

## 스마트 포인터 선택

프로그램이 하나의 객체에 대해 하나 이상의 포인터를 사용할시에는 `shared_ptr`을 선택해야함    
* 포인터의 배열과 특정 값을 지정하기 위한 보조 포인터들이 있는 프로그램
* 동일한 3개의 객체를 가리키는 2개의 객체가 있는 프로그램
* 포인터의 STL 컨테이너가 있는 프로그램 등

프로그램이 같은 객체를 가리키기 위해 다중 포인터를 필요로하지 않는다면 `unique_ptr`를 사용해야함    
이는 `new`로 대입된 메모리를 리턴하는 함수의 리턴 타입에 가장 적절한 선택임    
하나의 `unique_ptr`에서 다른 `unique_ptr`에 대입할 수 있는 상황과 동일한 상황인 경우 `unique_ptr`을 `shared_ptr`에도 대입할 수 있으나, 원본이 `rvalue`여야만함    


***
***


# 16.3 표준 템플릿 라이브러리

표준 템플릿 라이브러리(STL Standard Template Library)는 컨테이너(container), 이터레이터(iterator), 함수 객체(function object), 알고리즘(algorithm)을 나타내는 템플릿들의 집합을 제공함    
* 컨테이너 : 배열과 같이 여러개의 값을 저장할 수 있는 구성 단위
* 알고리즘 : 배열을 정렬하거나 특정 값 검색 등 특별한 작업들을 수행하기 위해 사용하는 방법
* 이터레이터 : 컨테이너 안에서 위치를 옮길 수 있도록 도와주는 객체, 포인터의 일반화
* 함수 객체 : 클래스 객체 / 함수 포인터

STL은 일반화 프로그래밍(generic programmin)의 패러다임을 나타냄    

## vector 템플릿 클래스

`vector`는 임의로 접근할 수 있는 비슷한 값들의 집합을 저장함    
`vector` 템플릿 객체를 생성할 때는 사용할 데이터형을 나타내기 위해 통상적인 `<type>` 표기와 동적 메모리 대입을 사용함    

```cpp
// vect1.cpp

#include <iostream>
#include <string>
#include <vector>

const int NUM = 5;

int main()
{
	using std::vector;
	using std::string;
	using std::cin;
	using std::cout;
	using std::endl;
	vector<int> ratings(NUM);
	vector<string> titles(NUM);

	cout << NUM << "개의 책 제목과 책 등급(0-10)을 입력하십시오.\n";
	int i;
	for (i = 0; i < NUM; i++)
	{
		cout << i + 1 << "번 책의 제목을 입력하십시오 : ";
		getline(cin, titles[i]);
		cout << i + 1 << "번 책의 등급(0-10)을 입력하십시오 : ";
		cin >> ratings[i];
		cin.get();
	}
	cout << "감사합니다. 당신은 다음과 같이 입력하셨습니다 : \n"
		 << "등급\t제목\n";
	
	for (i = 0; i < NUM; i++)
		cout << ratings[i] << "\t" << titles[i] << endl;
	return 0;
}
```

***

## vector에서 할 수 있는 것

모든 STL 컨테이너들은 기본적인 메소드들을 제공함
* `size()` : 컨테이너에 있는 원소들의 개수를 리턴
* `swap()` : 두 컨테이너의 내용을 교환
* `begin()` : 컨테이너에 있는 첫번째 원소를 참조하는 이터레이터를 리턴
* `end()` : 컨테이너에 있는 마지막 원소 바로 다음(past-the-end)을 참조하는 이터레이터를 리턴

```cpp
vector<double>::iterator pd;
vector<double> scores;
pd = scores.begin();
*pd = 22.3;
++pd;
```

이터레이터는 포인터의 일반화로 실제 포인터일 수도 있고, 내용 참조(`operator*()`)나 증가(`operator++()`)와 같이 포인터를 닮은 연산들이 정의되어있는 객체일 수도 있음    
포인터를 이터레이터로 일반화할시 다양한 컨테이너 클래스들에 일관된 인터페이스를 제공할 수 있음    

```cpp
vector<double> scores;
vector<double> new_scores;
double temp;
while (cin >> temp && temp >= 0)
	scores.push_back(temp);
cout << scores.size() << "개의 점수가 입력되었습니다.\n";
scores.erase(scores.begin(), scores.begin() + 2);
...
scores.insert(scores.begin(), new_scores.begin() + 1, new_scores.end());
```

`vector` 템플릿 클래스는 일부 STL 컨테이너들만이 가지고 있는 몇가지 메소드를 가지고있음
* `push_bac()` : 벡터의 끝에 하나의 원소를 추가함    
	이 때 메소드는 메모리 관리에 관여하여 벡터의 크기를 늘림
* `erase()` : 지정된 범위를 벡터에서 삭제하며, 범위를 정의하는 2개의 이터레이터를 매개변수로 사용함    
* `insert()` : 이터레이터 매개변수를 3개 사용하여 첫번째 매개변수는 새로운 원소들이 삽입될 장소의 바로 앞 위치를 제공하며 두번째, 세번째 매개변수는 삽입에 사용할 범위를 정의함    

```cpp
// vect2.cpp

#include <iostream>
#include <string>
#include <vector>

struct Review {
	std::string title;
	int rating;
};

bool FillReview(Review & rr);
void ShowReview(const Review & rr);

int main()
{
	using std::cout;
	using std::vector;
	vector<Review> books;
	Review temp;

	while (FillReview(temp))
		books.push_back(temp);
	int num = books.size();
	if (num > 0)
	{
		cout << "감사합니다. 당신은 다음과 같이 입력하셨습니다.\n"
			 << "등급\t제목\n";
		for (int i = 0; i < num; i++)
			ShowReview(books[i]);
		cout << "한번 더 출력한다 : \n"
			 << "등급\t제목\n";
		vector<Review>::iterator pr;
		for (pr = books.begin(); pr != books.end(); pr++)
			ShowReview(*pr);
		
		vector<Review> oldlist(books);
		if (num > 3)
		{
			books.erase(books.begin() + 1, books.begin() + 3);
			cout << "삭제한 후 : \n";
			for (pr = books.begin(); pr != books.end(); pr++)
				ShowReview(*pr);
			books.insert(books.begin(), oldlist.begin() + 1, oldlist.begin() + 2);
			cout << "삽입한 후 : \n";
			for (pr = books.begin(); pr != books.end(); pr++)
				ShowReview(*pr);
		}
		
		books.swap(oldlist);
		cout << "oldlist와 books를 교환한 후 : \n";
		for (pr = books.begin(); pr != books.end(); pr++)
			ShowReview(*pr);
	}
	else
		cout << "입력한 것이 없어, 얻은 것이 없습니다.\n";
	return 0;
}

bool FillReview(Review & rr)
{
	std::cout << "책 제목을 입력하십시오(끝내려면 quit를 입력) : ";
	std::getline(std::cin, rr.title);
	if (rr.title == "quit")
		return false;
	std::cout << "책 등급(0-10)을 입력하십시오 : ";
	std::cin >> rr.rating;
	if (!std::cin)
		return false;
	while (std::cin.get() != '\n')
		continue;
	return true;
}

void ShowReview(const Review & rr)
{
	std::cout << rr.rating << "\t" << rr.title << std::endl;
}
```

***

## vector에서 할 수 있는 그 밖의 것

STL은 일반적인 작업을 위해 모든 컨테이너 클래스에 사용할 수 있는 멤버가 아닌 함수를 정의함    
동일한 작업을 하는 비멤버 함수가 있더라도 클래스에 특화된 알고리즘을 위해 멤버 함수를 따로 만드는 경우도 있음    
* `for_each()` : 지시된 함수를 그 범위 안에있는 각 컨테이너 원소에 적용
	* 단, 지시된 함수는 컨테이너 원소들의 값을 변경할 수 없음
	* 3개의 매개변수를 사용, 첫번째 두번째 매개변수는 컨테이너의 범위를 정의하는 이터레이터
	* 세번째 매개변수는 함수를 지시하는 포인터(일반적으로는 함수 객체)
* `random_shuffle()` : 범위 안에 있는 원소들을 무작위 순서로 재배치
	* 컨테이너 클래스가 임의 접근을 허용할 것을 요구함
	* 매개변수로 범위를 지정하는 두 개의 이터레이터를 사용
* `sort()` : 두 가지 버전이 있음    
	* 첫번째 버전은 범위를 지정하는 두 개의 이터레이터를 사용하며, 컨테이너에 저장되어있는 데이터형의 원소에 맞게 정의된 `<` 연산자를 사용하여 정렬함    
	* 따라서 컨테이너의 원소들이 사용자 정의 객체라면 해당 데이터형에 맞게 정의된 `operator<()` 함수가 있어야함
	* 두번째 버전은 3개의 매개변수를 사용하며 첫번째와 두번째는 범위 지정 이터레이터, 세번째는 값을 비교하기 위해 `operator<()` 대신에 사용할 함수를 지시하는 포인터(일반적으로는 함수 객체)를 사용함
	* 이 때 해당 함수의 리턴값은 `bool`형으로 변환할 수 있어야함

```cpp
// vect3.cpp

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Review {
	std::string title;
	int rating;
};

bool operator<(const Review & r1, const Review & r2);
bool worseThan(const Review & r1, const Review & r2);
bool FillReview(Review & rr);
void ShowReview(const Review & rr);

int main()
{
	using namespace std;

	vector<Review> books;
	Review temp;

	while (FillReview(temp))
		books.push_back(temp);

	if (books.size() > 0)
	{
		cout << "감사합니다. 당신은 다음과 같이 "
			 << books.size() << "개의 책 등급을 입력하셨습니다.\n"
			 << "등급\t제목\n";
		for_each(books.begin(), books.end(), ShowReview);

		sort(books.begin(), books.end());
		cout << "책 제목을 기준으로 정렬 : \n등급\t제목\n";
		for_each(books.begin(), books.end(), ShowReview);

		sort(books.begin(), books.end(), worseThan);
		cout << "책 등급을 기준으로 정렬 : \n등급\t제목\n";
		for_each(books.begin(), books.end(), ShowReview);

		random_shuffle(books.begin(), books.end());
		cout << "무작위 순서로 다시 배치 : \n등급\t제목\n";
		for_each(books.begin(), books.end(), ShowReview);
	}
	else
		cout << "프로그램을 종료합니다.\n";
	return 0;
}

bool operator<(const Review & r1, const Review & r2)
{
	if (r1.title < r2.title)
		return true;
	else if (r1.title == r2.title && r1.rating < r2.rating)
		return true;
	else
		return false;
}

bool worseThan(const Review & r1, const Review & r2)
{
	if (r1.rating < r2.rating)
		return true;
	else
		return false;
}

bool FillReview(Review & rr)
{
	std::cout << "책 제목을 입력하십시오(끝내려면 quit를 입력) : ";
	std::getline(std::cin, rr.title);
	if (rr.title == "quit")
		return false;
	std::cout << "책 등급(0-10)을 입력하십시오 : ";
	std::cin >> rr.rating;
	if (!std::cin)
		return false;
	while (std::cin.get() != '\n')
		continue;
	return true;
}

void ShowReview(const Review & rr)
{
	std::cout << rr.rating << "\t" << rr.title << std::endl;
}
```

***

# Range에 기초한 루프(C++11)

```cpp
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
for (double x : pries)
	cout << x << std::end;

for_each(book.vegin(), books.end(), ShowReview);
for (auto x : books) ShowReview(x);
```

`for` 루프 헤드에 컨테이너에 저장된 형으로 변수를 선언한 다음 컨테이너의 이름을 선언    
그 후 루프의 몸체에 명명된 변수를 사용하여 각각의 저장소 요소에 접근함    
`for_each()`와는 달리 `range`에 기초한 `for`는 저장소의 내용을 수정할 수 있으며, 이를 위해서는 참조 매개변수를 사용해야함    

```cpp
void InflateReview(Review &r) {r.rating++;}
for (auto & x : books) InflateReview(x);
```


***
***


# 16.4 일반화 프로그래밍


STL은 일반화 프로그래밍의 한 예로 알고리즘에 중점을 둠    
일반화 프로그램ㅇ의 목적은 데이터형과 무관한 코드를 작성하는 것으로, 템플릿을 사용하여 함수나 클래스를 일반형으로 정의할 수 있으나 STL은 알고리즘의 일반화된 표현을 제공함으로써 한발 더 나아감    

## 이터레이터가 필요한 이유

템플릿이 알고리즘을 저장할 데이터형과 무관하게 만드는 것과 같이 이터레이터는 알고리즘을 사용할 컨테이너형과 무관하게 만듬    

```cpp
double * find_ar(double * ar, int n, const double & val)
{
	for (int i = 0; i < n; i++)
		if (ar[i] == val)
			return &ar[i];
	return 0;
}

struct Node
{
	double item;
	Node * p_next;
};

Node* find_ll(Node * head, const double & val)
{
	Node * start;
	for (start = head; start != 0; start = start->p_next)
		if (start->item == val)
			return start;
	return 0;
}
```

`find_ar` 함수에서 템플릿을 사용할경우 `==` 연산자를 지원하는 모든 데이터형의 배열에까지 일반화할 수 있음    
그러나 이는 배열이라는 특정 데이터 구조에만 적용이 가능함    
마찬가지로 `find_ll` 함수에서도 템플릿을 사용하면 `==` 연산자를 지원하는 모든 데이터형의 링크드 리스트에 일반화할 수 있으나, 여전히 링크드리스트라는 특정 데이터 구조에만 적용이 가능함    

`find` 함수를 일반화하기 위해 이터레이터가 가져야하는 특성
* 이터레이터가 참조하는 값에 접근하기 위해 내용 참조(dereference)를 할 수 있어야하며 즉, `p`가 이터레이터라면 `*p`가 정의되어야함
* 한 이터레이터를 다른 이터레이터에 대입할 수 있어야하며 즉, `p`와 `q`가 이터레이터라면 `p = q`라는 표현이 정의되어야함
* 한 이터레이터가 다른 이터레이터와 같은 것인지 비교할 수 있어야하며 즉 `p == q`와 `p != q`라는 표현이 정의되어야함
* 이터레이터가 컨테이너에 들어있는 모든 원소들을 훑고 지나갈 수 있어야하며, 즉 `++p`와 `p++`가 정의되어야함    

이 때 단순 포인터가 위의 요구사항을 모두 만족시킬 수 있음

```cpp
typedef double * iterator;
iterator find_ar(iterator begin, iterator end, const double * val)
{
	iterator ar;
	for (ar = begin; ar != end; ar++)
		if (*ar == val)
			return ar;
	return end;
}
```

```cpp
struct Node
{
	double item;
	Node * p_next;
};

class iterator
{
	Node * pt;
	public:
		iterator() : pt(0) {}
		iterator(Node * pn) : pt(pn) {}
		double operator*() { return pt->item; }
		iterator& operator++()
		{
			pt = pt->p_next;
			return *this;
		}
		iterator operator++(int)
		{
			iterator tmp = *this;
			pt = pt->p_next;
			return tmp;
		}
};

iterator find_ll(iterator head, const double & val)
{
	iterator start;
	for (start = head; start != 0; ++start)
		if (*start == val)
			return start;
	return 0;
}
```

`find_ar()` 함수와 `find_ll()` 함수는 구조가 거의 같음    
단,  `find_ar()` 함수는 past-the-end를 가리키는 이터레이터를 사용하며 `find_ll()` 함수는 마지막 노드에 저장된 널 값을 사용함    
따라서 링크드리스트가 공식적인 마지막 원소 뒤 바로 다음에 비공식적인 원소를 하나 더 갖게 만들어 past-the-end 원소를 갖게 할 경우 `find_ar()`과 `find_ll`의 알고리즘이 동일해짐    
즉, past-the-end 원소를 요구함으로써 이터레이터들에 대한 요구사항을 컨테이너 클래스에 대한 요구사항으로 바꿈    

STL에서 각각의 컨테이너 클래스들은 그 클래스에 맞는 이터레이터형을 정의함    
이는 포인터, 객체 등 여러가지가 가능하며 이터레이터는 `*`나 `++`와 같이 필요한 연산을 제공함    
이후 각 컨테이너 클래스는 컨테이너에 있는 마지막 값 바로 다음으로 증가되었을 때 이터레이터에 대입되는 값으로 past-the-end 마커를 가짐    
각 컨테이너 클래스는 `begin()`과 `end()` 메소드를 가지며, `++`연산을 가짐    

```cpp
vector<double>::iterator pr;
for (pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;

list<double>::iterator pr;
for (pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
```

위와 같이 각 클래스를 위한 적절한 이터레이터를 정의하고 클래스들을 일관된 방식으로 설계할시 STL을 사용하여 내부적 표현이 서로 다른 여러 컨테이너들에 대해 동일한 코드를 작성할 수 있음    

```cpp
for (auto pr = scores.begin(); pr !- scores.end(); pr++)
	cout << *pr << endl;
```

C++ 자동 타입 추론을 통해서 코드를 더욱 간단하게 만들 수도 있음    

일반화 알고리즘을 구체적인 사례에 적용하기 위해 알고리즘의 요구사항을 만족시키는 이터레이터들을 정의하고, 필요한 요구사항을 컨테이너 설계에 반영    
즉, 기본적인 이터레이터 특성과 컨테이너 특성은 알고리즘이 부과하는 요구사항에 따름    

***

## 이터레이터의 종류