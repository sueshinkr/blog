---
title:  "C++ Primer 11"
excerpt: "클래스의 활용"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.09.19 12:00:00
---

# 학습목표
* 연산자 오버로딩
* 프렌드 함수
* 출력을 위한 `<<` 연산자 오버로딩
* 상태 멤버
* `rand()` 함수를 이용한 무작위 값 생성
* 클래스와 관련된 자동 데이터형 변환과 데이터형 캐스트
* 클래스 변환 함수

***

# 11.1 연산자 오버로딩

연산자 오버로딩(operator overloading) : 연산자들에 다중적인 의미 부여    
* C++에서는 연산자 오버로딩을 사용자 정의 데이터형에도 적용할 수 있음    
* 연산자 오버로딩을 위해서는 `operatorop(argument-list)`의 형식을 가진 연산자 함수(operator function)라는 특별한 함수를 사용해야함    
* 이때의 `op`는 적법한 C++ 연산자여야하며, 같은 클래스의 객체들끼리 오버로딩된 연산자를 사용할 경우 해당 연산자가 연산자 함수로 대체됨


***
***


# 11.2 잠깐의 휴식 : 연산자 오버로딩 예제

```cpp
// mytime0.h

#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
	private:
		int hours;
		int minutes;
	public:
		Time();
		Time(int h, int m = 0);
		void AddMin(int m);
		void AddHr(int h);
		void Reset(int h = 0, int m = 0);
		Time Sum(const Time & t) const;
		void Show() const;
};

#endif
```

```cpp
// mytime0.cpp

#include <iostream>
#include "mytime0.h"

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::Sum(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

void Time::Show() const
{
	std::cout << hours << "시간, " << minutes << "분";
}
```

`Sum() 함수에서는 새로운 `Time` 객체를 만들고, 이 함수를 호출한 함수가 해당 객체를 사용할 수 있도록 복사본 개체를 리턴함    
이 때 만약 리턴형이 참조라면 참조는 생성된 객체 자신이 되지만 이는 지역변수이기 때문에 함수 종료시 파괴되어 참조가 어긋나게됨    

```cpp
// usetime0.cpp

#include <iostream>
#include "mytime0.h"

int main()
{
	using std::cout;
	using std::endl;
	Time planning;
	Time coding(2, 40);
	TIme fixing(5, 55);
	TIme total;

	cout << "planning time = ";
	planning.Show()
	cout << endl;

	cout << "coding time = ";
	coding.Show()
	cout << endl;

	cout << "fixing time = ";
	fixing.Show()
	cout << endl;

	total = coding.Sum(fixing);
	cout << "coding.Sum(fixing) = ";
	total.Show();
	cout << endl;
	return 0;
}
```

## 덧셈 연산자의 추가

```cpp
// mytime1.h

#ifndef MYTIME1_H_
#define MYTIME1_H_

class Time
{
	private:
		int hours;
		int minutes;
	public:
		Time();
		Time(int h, int m = 0);
		void AddMin(int m);
		void AddHr(int h);
		void Reset(int h = 0, int m = 0);
		Time operator+(const Time & t) const;
		void Show() const;
};

#endif
```

```cpp
// mytime1.cpp

#include <iostream>
#include "mytime1.h"

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

void Time::Show() const
{
	std::cout << hours << "시간, " << minutes << "분";
}
```

`Sum()`을 `operator+()`로 바꾸어 오버로딩된 덧셈 연산자를 사용

```cpp
// usetime1.cpp

#include <iostream>
#include "mytime1.h"

int main()
{
	using std::cout;
	using std::endl;
	Time planning;
	Time coding(2, 40);
	Time fixing(5, 55);
	Time total;

	cout << "planning time = ";
	planning.Show();
	cout << endl;

	cout << "coding time = ";
	coding.Show();
	cout << endl;

	cout << "fixing time = ";
	fixing.Show();
	cout << endl;

	total = coding + fixing;
	cout << "coding + fixing = ";
	total.Show();
	cout << endl;

	Time morefixing(3, 28);
	cout << "more fixing time = ";
	morefixing.Show();
	cout << endl;
	total = morefixing.operator+(total);
	cout << "morefixing.operator+(total) = ";
	total.Show();
	cout << endl;

	return 0;
}
```

`operator+()`역시 객체에 의해 호출할 수 있으며, `total = coding.operator+(fixing);`과 같이 `Sum()`에서 쓰던 것과 동일한 문법을 사용할 수 있음    
그러나 연산자 오버로딩을 활용하여 `total = coding + fixing`의 형식으로도 사용할 수 있음    
이 때 연산자 왼쪽의 객체가 호출한 객체, 오른쪽 객체가 매개변수로 전달되는 객체가 됨    

두 개 이상의 객체의 연산에도 적용 가능함    
`t4 = t1 + t2 + t3;`는 `t4 = t1.operator+(t2 + t3);`와 같고, 이는 `t4 = t1.operator+(t2.operator+(t3));`와 동일함    

***

## 오버로딩 제약

오버로딩된 연산자는 적어도 하나의 피연산자가 사용자 정의 데이터형일 것을 요구함    
* 즉, 표준 데이터형을 위해 사용되는 연산자들의 오버로딩을 방지함

오버로딩된 연산자를 원래의 연산자에 적용되는 문법 규칙을 위반하는 방식으로는 사용할 수 없음
* 즉, 나머지 연산자 `%`를 하나의 피연산자에만 작용하도록 만들 수 없음
* 연산자 우선순위 역시 원래의 연산자와 동일함

연산자 기호를 새로 만들 수 없음
* 즉, 거듭제곱을 나타내기 위해 `**`를 정의할 수 없음

다음과 같은 연산자들은 오버로딩할 수 없음
* `sizeof` : `sizeof`연산자, `.` : 멤버 연산자, `.*` : 멤버 지시 포인터 연산자
* `::` : 사용 범위 결정 연산자, `?:` : 조건 연산자, `typeid` : `RTTI` 연산자
* `const_cast` / `dynamic_cast` / `reinterpret_cast` / `static_cast` : 데이터형 변환 연산자

다음의 연산자들은 오버로딩 자체는 가능하나, 오버로딩하는데 멤버 함수만 사용할 수 있음
* `=` : 대입 연산자, `()` : 함수 호출 연산자
* `[]` : 배열 인덱스 연산자, `->` : 클래스 멤버 접근 포인터 연산자

오버로딩으로 사용된 연산자가 어떤 역할을 하는지 직관적으로 떠오르지 않는다면, 보다 설명적인 이름을 가진 클래스 메소드로 정의하는 것이 권장됨    

***

## 오버로딩 연산자 보충

```cpp
// mytime2.h

#ifndef MYTIME2_H_
#define MYTIME2_H_

class Time
{
	private:
		int hours;
		int minutes;
	public:
		Time();
		Time(int h, int m = 0);
		void AddMin(int m);
		void AddHr(int h);
		void Reset(int h = 0, int m = 0);
		Time operator+(const Time & t) const;
		Time operator-(const Time & t) const;
		Time operator*(double n) const;
		void Show() const;
};

#endif
```

```cpp
// mytime2.cpp

#include <iostream>
#include "mytime2.h"

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

Time Time::operator-(const Time & t) const
{
	Time diff;
	int tot1, tot2;
	tot1 = t.minutes + 60 * t.hours;
	tot2 = minutes + 60 * hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}

Time Time::operator*(double mult) const
{
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}

void Time::Show() const
{
	std::cout << hours << "시간, " << minutes << "분";
}
```

```cpp
// usetime2.cpp

#include <iostream>
#include "mytime2.h"

int main()
{
	using std::cout;
	using std::endl;
	Time weeding(4, 35);
	Time waxing(2, 47);
	Time total;
	Time diff;
	Time adjusted;

	cout << "weeding time = ";
	weeding.Show();
	cout << endl;

	cout << "waxing time = ";
	waxing.Show();
	cout << endl;

	cout << "total work time = ";
	total = weeding + waxing;
	total.Show();
	cout << endl;

	diff = weeding - waxing;
	cout << "weeding time - waxing time = ";
	diff.Show();
	cout << endl;

	adjusted = total * 1.5;
	cout << "adjusted work time = ";
	adjusted.Show();
	cout << endl;

	return 0;
}
```


***
***


# 11.3 프렌드의 도입

C++은 클래스 객체의 `private` 부분에 접근하기 위해 `public` 클래스 메소드가 아닌 프렌드(friend)라는 또 하나의 접근 통로를 제공함
* 프렌드는 프렌드 함수 / 클래스 / 멤버 함수의 세가지 형태로 사용됨
* 함수를 어떤 클래스에 대한 프렌드로 만들시 해당 프렌드 함수는 클래스의 멤버 함수와 동등한 접근 권한을 가짐
* 어떤 클래스에 대해 이항 연산자를 오버로딩할시 프렌드를 만들 필요성이 생김
	* 곱셈 오버로딩 연산자의 경우 `A = B * 2.75;`와 `A = 2.75 * B;`는 개념적으로 같아야하지만 2.75는 객체형이 아니기 때문에 `A = B.operator*(2.75)`로는 적용이 가능해도 그 반대는 가능하지 않음
	* 따라서 멤버가 아닌 함수를 사용해 객체 호출 없이 처리해야하지만, 멤버가 아닌 함수는 `private`의 데이터에 접근할 수 없기 때문에 프렌드가 필요해짐

## 프렌드 생성하기

프렌드 함수는 클래스 선언에 `friend` 키워드가 붙은 원형을 넣어 만듬
* 즉, `freind Time operator*(double m, const Time & t);`의 형식으로 원형 선언
* `operator*()` 함수는 클래스 선언 안에 선언되지만 멤버 함수가 아니며, 멤버 함수와 동등한 접근 권한을 가짐

프렌드 함수는 멤버 함수가 아니기 때문에 함수 정의에 `Time::`과 같은 클래스 제한자를 사용하지 않음
```cpp
Time operator*(double m, const Time & t)
{
	Time result;
	long totalminutes = t.hours * m * 60 + t.minutes * m;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
```
위와 같이 프렌드 함수가 정의되면 `A = 2.75 * B;`는 `A = operator*(2.75, B);`로 번역되어 프렌드 함수를 호출함    

```cpp
Time operator*(double m, const TIme & t)
{
	return t * m;
}
```
위와 같이 사용할경우 `t.operator*(m)`을 사용하여 프렌드가 아닌 함수로도 작성이 가능하지만, 프렌드로 만드는 것이 바람직함
* 함수가 클래스의 공식 인터페이스의 일부로 결합되기 때문
* 함수가 `private` 데이터에 직접 접근할 필요가 생길시 클래스 선언의 원형은 그대로 두고 함수 정의만 바꾸면 됨

***

## 프렌드 : << 연산자의 오버로딩

클래스에 `<<` 연산자를 오버로딩하여 `cout`과 함께 사용해 객체의 내용을 출력할 수 있음    
`ostream` 클래스 선언은 기본 데이터형 각각에 대해 오버로딩된 `operator<<()` 정의를 가지고있는 것처럼, `cout`이 클래스 객체를 인식하도록 하기 위해서는 `ostream`에 새로운 연산자 함수의 정의를 추가해야함    
그러나 사용자가 직접 표준 인터페이스를 건드리는 것은 위험하기 때문에, 클래스에 `cout`을 사용하는 방법을 가르치는 것이 권장됨    

```cpp
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << "시간, " << t.minutes << "분";
}
```
`trip`이라는 `Time`클래스의 객체가 있을 때, `cout << trip;`과 같은 구문에서는 `ostream`클래스 객체인 `cout`이 첫번째 피연산자로 인식되기 때문에 해당 구문을 사용하기 위해서는 프렌드 함수가 필요함    
이 때 `cout` 객체는 객체의 복사본이 아닌 그 자체여야하므로 값이 아닌 참조로 전달함    

```cpp
ostream & operator<<(ostream & os, const Time & t)
{
	os << t.hours << "시간, " << t.minutes << "분";
	return os;
}
```

`cout << "여행 일시 : " << trip << " (화요일)\n";`과 같은 구문이 있을 경우 이전의 `void`형 `operator<<()`함수로는 정상 작동하지 않음    
이는 C++에서의 출력 구문이 왼쪽에서부터 읽히며, 따라서 이 구문은 `((cout << "여행 일시 : ") << trip) << " (화요일)\n";`과 같음    
`ostream` 클래스의 `operator<<` 함수가 `ostream` 객체를 리턴하기 때문에 `cout << "여행 일시 : "`의 경우 하나의 객체가 되어 뒤에 오는 `<< trip`도 정상적으로 작동됨    
따라서 프렌드 함수로 지정한 `operator<<()`도 `ostream` 객체에 대한 참조를 리턴하도록 만들어야함      

```cpp
// mytime3.h

#ifndef MYTIME3_H_
#define MYTIME3_H_
#include <iostream>

class Time
{
	private:
		int hours;
		int minutes;
	public:
		Time();
		Time(int h, int m = 0);
		void AddMin(int m);
		void AddHr(int h);
		void Reset(int h = 0, int m = 0);
		Time operator+(const Time & t) const;
		Time operator-(const Time & t) const;
		Time operator*(double n) const;
		friend Time operator*(double m, const Time & t)
			{ return t * m; };
		friend std::ostream & operator<<(std::ostream & os, const Time & t);
};

#endif
```

```cpp
// mytime3.cpp

#include "mytime3.h"

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

Time Time::operator-(const Time & t) const
{
	Time diff;
	int tot1, tot2;
	tot1 = t.minutes + 60 * t.hours;
	tot2 = minutes + 60 * hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}

Time Time::operator*(double mult) const
{
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}

std::ostream & operator<<(std::ostream & os, const Time & t)
{
	os << t.hours << "시간, " << t.minutes << "분";
	return os;
}
```

```cpp
// usetime3.cpp

#include "mytime3.h"

int main()
{
	using std::cout;
	using std::endl;
	Time aida(3, 35);
	Time tosca(2, 48);
	Time temp;

	cout << "Aida와 Tosca:\n";
	cout << aida << "; " << tosca << endl;
	temp = aida + tosca;
	cout << "Aida + Tosca : " << temp << endl;
	temp = aida * 1.17;
	cout << "Aida * 1.17 : " << temp << endl;
	cout << "10 * Tosca : " << 10 * tosca << endl;
	return 0;
}
```