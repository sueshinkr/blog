---
title:  "C++ Primer 13"
excerpt: "클래스의 상속"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.09.27 14:00:00
---

# 학습목표
* is - a 관계로 상속하기
* 다른 클래스로부터 `public`으로 파생된 클래스
* `protected` 접근
* 생성자 멤버 초기자 리스트
* 업캐스팅과 다운캐스팅
* 가상 멤버 함수
* 초기 (정적) 결합과 말기 (동적) 결합
* 추상화 기초 클래스
* 순수 가상 함수
* `public` 상속은 언제 어떻게

C++은 클래스를 확장하고 수정하기 위해 단순하게 코드를 수정하는 것이 아닌, 클래스 상속(class inheritance)라는 강력한 수단을 제공함    
클래스 상속은 기초 클래스(base class)로부터 모든 메소드와 멤버들을 상속받아 새로운 파생 클래스(derived class)를 만들 수 있게 함    
* 기존의 클래스에 기능을 추가할 수 있음
* 클래스가 나타내고있는 데이터에 다른 것을 더 추가할 수 있음
* 클래스 메소드가 동작하는 방식을 변경할 수 있음

***

# 13.1 간단한 기초 클래스로부터 시작

```cpp
// tabtenn0.h

#ifndef TABTENN0_H_
#define TABTENN0_H_

#include <string>
using std::string;

class TableTennisPlyaer
{
	private:
		string firstname;
		string lastname;
		bool hasTable;
	public:
		TableTennisPlyaer(const string & fn = "none",
						  const string & ln = "none",
						  bool ht = false);
		void Name() const;
		bool HasTable() const { return hasTable; };
		void ResetTable(bool v) { hasTable = v; };
};

#endif
```

```cpp
// tabtenn0.cpp

#include "tabtenn0.h"
#include <iostream>

TableTennisPlayer::TableTennisPlayer (const string & fn,
	const string & ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
	std::cout << lastname << ", " << firstname;
}
```

생성자에 멤버 초기자 리스트 구문을 사용하여 `string` 복사 생성자를 사용해 `firstname`을 `fn`으로 초기화하는 한 단계를 생략함    

```cpp
// usett0.cpp

#include <iostream>
#include "tabtenn0.h"

int main()
{
	using std::cout;
	TableTennisPlayer player1("Chunk", "Blizzard", true);
	TableTennisPlayer player2("Tara", "Boomdea", false);
	player1.Name();
	if (player1.HasTable())
		cout << " : 탁구대가 있다.\n";
	else
		cout << " : 탁구대가 없다.\n";
	player2.Name();
	if (player2.HasTable())
		cout << " : 탁구대가 있다.\n";
	else
		cout << " : 탁구대가 없다.\n";

	return 0;
}
```

표준 `string` 클래스는 `const char*`형의 매개변수를 지닌 생성자를 가지고있음    
따라서 `string` 객체는 `const string &`형의 매개변수를 지닌 `string` 생성자를, C스타일 `string`은 `const char*`형의 매개변수를 지닌 `string` 생성자를 불러옴    
즉, `TableTennisPlyaer` 생성자에 대한 매개변수로 `string` 객체 혹은 C스타일 `string` 둘 중 어느 것을 사용해도 무방함    

## 클래스 파생시키기

`class RatedPlayer : public TableTennisPlayer { ... };`형태로 클래스 파생    
`:`으로 `RatedPlayer` 클래스가 `TableTennisPlayer`에 기초를 둔 파생 클래스란 것을 나타내고, 이를 `public 파생`(public derivation)이라고 함    
* 기초 클래스의 `public` 멤버들이 파생 클래스의 `public` 멤버가 됨
* 기초 클래스의 `private` 부분도 파생 클래스의 일부가 되지만 기초 클래스의 `protected` 또는 `public` 메소드를 통해서만 접근할 수 있음
* 파생 클래스형의 객체 안에는 기초 클래스형의 데이터 멤버들이 저장됨
* 파생 클래스형의 객체는 기초 클래스형의 메소드들을 사용할 수 있음
* 즉, 파생 클래스는 기초 클래스의 구현과 인터페이스를 상속받음

```cpp
class RatedPlayer : public TableTennisPlayer
{
	private:
		unsigned int rating;
	public:
		RatedPlayer(unsigned int r = 0, const char * fn = "none",
					const string & ln = "none", bool ht = false);
		RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
		unsigned int Rating() { return rating; }
		void ResetRating(unsigned int r) { rating = r; };
};
```

파생 클래스는 자기 자신의 생성자를 필요로하며, 이 때 생성자는 새로 추가된 데이터 멤버와 상속받은 데이터 멤버들에 데이터를 제공해야함    
파생 클래스에는 부가적인 데이터 멤버 및 멤버 함수들을 필요한만큼 추가할 수 있음    

***

## 생성자 : 접근에 대하여

파생 클래스는 기초 클래스의 `private` 멤버에 직접 접근할 수 없기 때문에 기초 클래스의 메소드를 통해서 접근해야함    
따라서 파생 클래스의 생성자는 기초 클래스의 생성자를 사용해야함    

```cpp
RatedPlayer::RatedPlayer(unsigned int r, const char * fn,
						 const string & ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
	rating = r;
}
```
파생 클래스의 객체 생성시 먼저 기초 클래스 객체가 생성됨    
이를 위해 C++에서는 멤버 초기자 리스트 문법이 사용됨    
* `: TableTennisPlayer(fn, ln, ht)`가 멤버 초기자 리스트이며, 이는 `TableTennisPlayer` 생성자를 호출함
* 멤버 초기자 리스트를 생략할시 기초 클래스의 디폴트 생성자가 사용됨

```cpp
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp), rating(r)
{
}
```

`TableTennisPlayer(tp)`에서 `tp`는 `TableTennisPlayer &`형이기 때문에 기초 클래스의 복사 생성자를 호출함    
이 때 복사 생성자가 정의되어있지 않은 경우 컴파일러는 복사 생성자를 자동으로 생성함    
파생 클래스의 멤버들에도 멤버 초기자 리스트 문법을 사용할 수 있음    

객체 파괴시 생성과 반대 순서로 파생 클래스 파괴자가 먼저 실행되고, 이후에 기초 클래스 파괴자가 자동으로 호출됨    

***

## 파생 클래스 사용하기

```cpp
// tabtenn1.h

#ifndef TABTENN1_H_
#define TABTENN1_H_

#include <string>
using std::string;

class TableTennisPlayer
{
	private:
		string firstname;
		string lastname;
		bool hasTable;
	public:
		TableTennisPlayer(const string & fn = "none",
						  const string & ln = "none",
						  bool ht = false);
		void Name() const;
		bool HasTable() const { return hasTable; };
		void ResetTable(bool v) { hasTable = v; };
};

class RatedPlayer : public TableTennisPlayer
{
	private:
		unsigned int rating;
	public:
		RatedPlayer(unsigned int r = 0, const char * fn = "none",
					const string & ln = "none", bool ht = false);
		RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
		unsigned int Rating() { return rating; }
		void ResetRating(unsigned int r) { rating = r; };
};

#endif
```

```cpp
// tabtenn1.cpp

#include "tabtenn1.h"
#include <iostream>

TableTennisPlayer::TableTennisPlayer (const string & fn,
	const string & ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
	std::cout << lastname << ", " << firstname;
}

RatedPlayer::RatedPlayer(unsigned int r, const char * fn,
						 const string & ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
	rating = r;
}

RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp), rating(r)
{
}
```

두 클래스가 서로 연계되어있기 때문에 클래스 선언 및 정의를 한 파일에 묶어두는 것이 더 체계적임    

```cpp
// usett1.cpp

#include <iostream>
#include "tabtenn1.h"

int main()
{
	using std::cout;
	using std::endl;

	TableTennisPlayer player1("Tara", "Boomdea", false);
	RatedPlayer rplayer1(1140, "Mallory", "Duck", true);

	rplayer1.Name();
	if (rplayer1.HasTable())
		cout << " : 탁구대가 있다.\n";
	else
		cout << " : 탁구대가 없다.\n";

	player1.Name();
	if (player1.HasTable())
		cout << " : 탁구대가 있다.\n";
	else
		cout << " : 탁구대가 없다.\n";

	cout << "이름 : ";
	rplayer1.Name();
	cout << "랭킹 : " << rplayer1.Rating() << endl;
	RatedPlayer rplayer2(1212, player1);
	cout << "이름 : ";
	rplayer2.Name();
	cout << "랭킹 : " << rplayer2.Rating() << endl;

	return 0;
}
```

***

## 파생 클래스와 기초 클래스의 특별한 관계

기초 클래스는 명시적 데이터형 변환 없이도 파생 클래스 객체를 지시할 수 있음    
기초 클래스 참조는 명시적 데이터형 변환 없이도 파생 클래스 객체를 참조할 수 있음    
단, 기초 클래스 포인터나 참조는 기초 클래스 메소드만 호출할 수 있음    

```cpp
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
TableTennisPlayer & rt = rplayer1;
TableTennisPlayer * pt = &rplayer1;
rt.Name();
pt->Name();

TableTennisPlayer player("Betsy", "Bloop", true);
RatedPlayer & rr = player; // 허용되지 않음
RatedPlayer * pr = player; // 허용되지 않음
```
기초 클래스의 참조형과 포인터형에는 파생 클래스의 객체나 주소를 대입할 수 있으나, 반대는 허용되지 않음    
기초 클래스에는 파생 클래스에 있는 멤버 등이 없을 수 있기 때문    
따라서 기초 클래스 참조나 포인터를 매개변수로 사용하는 함수는 기초 클래스 객체 및 파생 클래스 객체 모두에 사용할 수 있음    

```cpp
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer olaf2(olaf 1);
```

기초 클래스 객체를 파생 클래스 객체로 초기화시 암시적인 복사 생성자가 활용됨    
위와 같은 경우 `TableTennisPlayer(const TableTennisPlayer &);` 형태의 복사 생성자가 사용되며, 이는 `RatedPlayer` 객체인 `olaf1` 내부의 `TableTennisPLayer`객체로 `olaf2`를 초기화함    

```cpp
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer winner;
winner = olaf1;
```

파생 클래스 객체를 기초 클래스 객체에 대입시에는 암시적인 오버로딩 대입 연산자가 활용됨    
위와 같은 경우 `TableTennisPlayer & operator=(const TableTennisPlayer &) const;` 형태의 오버로딩 대입 연산자가 사용되며, 기초 클래스의 참조가 파생 클래스 객체를 참조하여 `olaf1`의 기초 클래스 부분이 `winner`에 복사됨    


***
***


# 13.2 상속 : is-a 관계

`public` 상속의 경우 `is-a` 관계로서 파생 클래스 객체가 기초 클래스 객체이기도 하다는 것을 뜻함    
이 경우엔 기초 클래스 객체를 대상으로 수행할 수 있는 모든 작업을 파생 클래스 객체에 대해서도 수행할 수 있음    

`public` 상속은 `has-a` 관계 및 `is-like-a` 관계나 `is-implemented-as-a` 관계, `uses-a` 관계를 나타내지 않음    
* `has-a` : 점심이 과일을 가질 수는 있어도 일반적으로 점심은 과일이 아니기 때문에 `Fruit` 클래스로부터 `Lunch` 클래스를 파생시키는 것은 옳지 않음
* `is-like-a` : 변호사는 상어와 같다고 말할 수 있더라도, 변호사는 상어가 아니기 때문에 `Shark` 클래스로부터 `Lawyer` 클래스를 파생시킬 수 없음
* `is-implemented-as-a` : 스택을 배열을 사용하여 구현할 수 있더라도, 스택은 배열이 아니며 다른 방법으로도 구현될 수 있기 때문에 `Array` 클래스로부터 `Stack` 클래스를 파생시킬 수 없음
* `uses-a` : 컴퓨터가 레이저프린터를 사용할 수 있더라도 `Computer` 클래스로부터 `Printer`를 파생시키는 것 혹은 그 반대는 이치에 맞지 않음    


***
***


# 13.3 public 다형 상속

파생 클래스에 대한 행동이 기초 클래스에 대한 행동과 다른 메소드가 요구되는 상황이 발생할 수 있음    
즉, 호출하는 객체에 따라 메소드의 행동이 달라질 수 있으며 이를 다형(polymorhphic)이라고 부름    

`public` 다형 상속을 구현하기 위한 방법
* 기초 클래스 메소드를 파생 클래스에서 다시 정의
* 가상 메소드를 사용

`Brass Account` 당좌를 위한 정보 : 고객 이름, 계좌번호, 현재 잔액
해당 계좌에 대해 허용할 연산 : 계좌 개설, 입금, 인출, 계좌 정보 출력
`Brass Plus Account`에 추가하고픈 정보 : 당좌 대월의 한도, 당좌 대월의 이자율, 상환할 원리금

## Brass와 BrassPlus 클래스의 개발

```cpp
// brass.h

#ifndef BRASS_H_
#define BRASS_H_

#include <string>

class Brass
{
	private:
		std::string fullName;
		long acctNum;
		double balance;
	public:
		Brass(const std::string & s = "Nullbody", long an = -1, double bal = 0.0);
		void Deposit(double amt);
		virtual void Withdraw(double amt);
		double Balance() const;
		virtual void ViewAcct() const;
		virtual ~Brass() {};
};

class BrassPlus : public Brass
{
	private:
		double maxLoan;
		double rate;
		double owesBank;
	public:
		BrassPlus(const std::string & s = "Nullbody", long an = -1, double bal = 0.0,
				  double ml = 500, double r = 0.11125);
		BrassPlus(const Brass & ba, double ml = 500, double r = 0.11125);
		virtual void ViewAcct() const;
		virtual void Withdraw(double amt);
		void ResetMax(double m) { maxLoan = m; };
		void ResetRate(double r) { rate = r; };
		void ResetOwes() { owesBank = 0; };
};

#endif
```

`BrassPlus` 클래스는 `Brass` 클래스에서 파생된 클래스임    
* 3개의 새로운 `private` 멤버와 `public` 멤버 함수가 추가됨
* 양 클래스 모두에 `ViewAcct()`와 `Withdraw()` 메소드가 선언되었으며, 각 클래스의 객체에 대한 행동이 다른 메소드임
* `Brass` 클래스에서 `virtual` 키워드를 사용해 가상 메소드(virtual method)를 선언함
* `Brass` 클래스는 아무 일도 하지않는 가상 파괴자를 선언함

```cpp
Brass dom("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();
b2_ref.ViewAcct();
```

가상 메소드는 메소드가 객체에 의해 호출되지 안혹 참조 또는 포인터에 의해 호출되었을 때 어느 메소드를 사용할 것인지를 객체형에 기초하여 결정함    
* `ViewAcct()`가 가상 메소드가 아닌 경우 : 참조 변수들이 `Brass`형이기 때문에 `Brass:ViewAcct()`가 선택됨
* `ViewAcct()`가 가상 메소드인 경우 : `b1_ref`는 `Brass`형 객체를 참조하기 때문에 `Brass::ViewAcct()`를, `b2_ref`는 `BrassPlus`형 객체를 참조하기 때문에 `BrassPlus::ViewAcct()`를 선택함
* 파생 클래스에서 다시 정의되는 메소드들은 기초 클래스에서 가상으로 선언하는 것이 일반적인 관행이며, 이 때 파생 클래스에서는 자동으로 가상 메소드가 되지만 `virtual` 키워드를 사용하여 명시하는 것이 권장됨    

```cpp
// brass.cpp

#include "brass.h"
#include <iostream>
using std::cout;
using std::endl;
using std::string;

typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f, precis p);

Brass::Brass(const string & s, long an, double bal)
{
	fullName = s;
	acctNum = an;
	balance = bal;
}

void Brass::Deposit(double amt)
{
	if (amt < 0)
		cout << "마이너스 입금은 허용되지 않습니다.\n"
			 << "그래서 입금이 취소되었습니다.\n";
	else
		balance += amt;
}

void Brass::Withdraw(double amt)
{
	format initialState = setFormat();
	precis prec = cout.precision(2);

	if (amt < 0)
		cout << "마이너스 인출은 허용되지 않습니다.\n"
			 << "그래서 인출이 취소되었습니다.\n";
	else if (amt <= balance)
		balance -= amt;
	else
		cout << "인출을 요구한 금액 $" << amt
			 << "가 현재 잔액을 초과합니다.\n"
			 >> "그래서 인출이 취소되었습니다.\n";
	restore(initialState, prec);
}

double Brass::Balance() const
{
	return balance;
}

void Brass::ViewAcct() const
{
	format initialState = setFormat();
	precis prec = cout.precision(2);
	cout << "고객 이름 : " << fullName << endl;
	cout << "계좌 번호 : " << acctNum << endl;
	cout << "현재 잔액 : $" << balance << endl;
	restore(initialState, prec);
}

BrassPlus::BrassPlus(const string & s, long an, double bal,
					 double ml, double r) : Brass(s, an, bal)
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}

BrassPlus::BrassPlus(const Brass & ba, double ml, double r)
	: Brass(ba)
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}

void BrassPlus::ViewAcct() const
{
	format initialState = setFormat();
	precis prec = cout.precision(2);

	Brass::ViewAcct();
	cout << "당좌 대월 한도액 : $" << maxLoan << endl;
	cout << "상환할 원리금 : $" << owesBank << endl;
	cout.precision(3);
	cout << "당좌 대월 이자율 : " << 100 * rate << "%\n";
	restore(initialState, prec);
}

void BrassPlus::Withdraw(double amt)
{
	format initialState = setFormat();
	precis prec = cout.precision(2);

	double bal = Balance();
	if (amt <= bal)
		Brass::Withdraw(amt);
	else if (amt <= bal + maxLoan - owesBank)
	{
		double advance = amt - bal;
		owesBank += advance * (1.0 + rate);
		cout << "당좌 대월 금액 : $" << advance << endl;
		cout << "당좌 대월 이자 : $" << advance * rate << endl;
		Deposit(advance);
		Brass::Withdraw(amt);
	}
	else
		cout << "당좌 대월 한도가 초과되어 거래가 취소되었습니다.\n";
	restore(initialState, prec);
}

format setFormat()
{
	return cout.setf(std::ios_base::fixed,
					 std::ios_base::floatfield);
}

void restore(format f, precis p)
{
	cout.setf(f, std::ios_base::floatfield);
	cout.precision(p);
}
```

`BrassPlus`의 생성자들은 멤버 초기자 리스트 문법을 이용하여 기초 클래스의 `private` 데이터를 초기화함    
`ViewAcct()` 함수를 `BrassPlus` 버전에 재정의함으로써 서로 다른 동작을 하도록 만듬    
* `BrassPlus::ViewAcct()`에서 `Brass::ViewAcct()` 메소드를 호출할 때 사용 범위 연산자를 사용하는 것이 중요함    

`Withdraw()` 함수 역시 양 클래스에서 다르게 동작함
* `BrassPlus::Withdraw()`에서 쓰이는 `Balance()` 함수는 파생 클래스에서 재정의되지 않기 때문에 사용 범위 결정 연산자가 불필요함

```cpp
// usebrass1.cpp

#include <iostream>
#include "brass.h"

int main()
{
	using std::cout;
	using std::endl;

	Brass Piggy("Porcelot Pigg", 381299, 4000.00);
	BrassPlus Hoggy("Horatio Hogg", 382288, 3000.00);
	Piggy.ViewAcct();
	cout << endl;
	Hoggy.ViewAcct();
	cout << endl;
	cout << "Hogg씨의 계좌에 $1000 입금 : \n";
	Hoggy.Deposit(1000.00);
	cout << "Hogg씨의 현재 잔액 : $" << Hoggy.Balance() << endl;
	cout << "Pigg씨의 계좌에서 $4200 인출 :\n";
	Piggy.Withdraw(4200.00);
	cout << "Pigg씨의 현재 잔액 : $" << Piggy.Balance() << endl;
	cout << "Hogg씨의 계좌에서 $4200 인출 :\n";
	Hoggy.Withdraw(4200.00);
	Hoggy.ViewAcct();

	return 0;
}
```

```cpp
// usebrass2.cpp

#include <iostream>
#include <string>
#include "brass.h"
const int CLIENTS = 4;

int main()
{
	using std::cin;
	using std::cout;
	using std::endl;

	Brass * p_clients[CLIENTS];
	std::string temp;
	long tempnum;
	double tempbal;
	char kind;

	for (int i = 0; i < CLIENTS; i++)
	{
		cout << "고객의 이름을 입력하십시오 : ";
		getline(cin, temp);
		cout << "고객의 계좌 번호를 입력하십시오 : ";
		cin >> tempnum;
		cout << "계좌 개설 잔액을 입력하십시오 : $";
		cin >> tempbal;
		cout << "Brass 계좌는 1, "
			 << "BrassPlus 계좌는 2를 입력하십시오 : ";
		while (cin >> kind && (kind != '1' && kind != '2'))
			cout << "1 아니면 2, 둘 중 하나를 입력하십시오 : ";
		if (kind == '1')
			p_clients[i] = new Brass(temp, tempnum, tempbal);
		else
		{
			double tmax, trate;
			cout << "당좌 대월 한도를 입력하십시오 : $";
			cin >> tmax;
			cout << "당좌 대월 이자율을 소수점 형식으로 "
				 << "입력하십시오 : ";
			cin >> trate;
			p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
		}
		while (cin.get() != '\n')
			continue;
	}
	cout << endl;
	for (int i = 0; i < CLIENTS; i++)
	{
		p_clients[i]->ViewAcct();
		cout << endl;
	}

	for (int i = 0; i < CLIENTS; i++)
	{
		delete p_clients[i];
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}
```

`Brass::ViewAcct()` 함수가 가상으로 선언되었기 때문에 `p_clients` 포인터가 지시하는 객체의 종류에 따라 서로 다른 종류의 `ViewAcct()` 함수가 호출됨    
또한 객체형에 해당하는 파괴자를 호출하기 위해 가상 파괴자가 사용됨    