---
title:  "C++ Primer 09"
excerpt: "메모리 모델과 이름 공간"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.09.08 14:00:00
---

# 학습목표
* 분할 컴파일
* 기억 존속 시간, 사용 범위, 링크
* 위치 지정 `new`
* 이름 공간

***
# 9.1 분할 컴파일

C++은 프로그램을 구성하는 함수들을 별개에 파일에 넣는 것을 권장함    
파일들을 분할하여 컴파일한 후 하나의 최종 실행 프로그램으로 링크할 수 있는데, 이 때 어떤 하나의 파일을 수정할 경우 해당 파일만을 다시 컴파일하여 이미 컴파일되어있는 다른 파일들과 링크하는 방식으로 관리함    
* 규모가 큰 프로그램을 쉽게 관리할 수 있음
* Unix와 Linux에서는 `make`라는 프로그램이 해당 기능을 제공함
* 대부분의 통합개발 환경들도 `Project` 메뉴를 통해 비슷한 기능을 제공함

여러 파일에 동일한 데이터가 들어갈 경우, 수정의 편리함 및 오류 방지를 위해 해당 데이터들을 헤더 파일에 넣고 `#include`로 각각의 소스 파일로 포함시킴    
따라서 원본 프로그램을 세 부분으로 나눌 수 있음
* 중복으로 사용되는 데이터들이 들어있는 헤더 파일
* 해당 데이터들을 사용하는 함수들의 코드가 들어있는 소스 코드 파일
* 함수들흘 호출하는 코드가 들어있는 소스 코드 파일

헤더 파일에는 함수 정의나 변수 선언을 넣으면 안됨
* 함수 원형 / `#define`이나 `const`를 사용하여 정의하는 기호 상수
* 구조체 선언 / 클래스 선언 / 템플릿 선언 / 인라인 함수
* `<>`으로 헤더 파일을 지정할 경우 컴파일러는 호스트 시스템의 파일 시스템 영역을 탐색함 : 표준 헤더 파일에 사용
* `""`로 사용할 겨우 현재 작업 디렉토리나 소스 코드 디렉토리에서 탐색함 : 사용자 정의 헤더 파일에 사용

```cpp
// coordin.h

#ifndef COORDIN_H_
#define COORDINI_H_

struct polar
{
	double distance;
	double angle;
};
struct rect
{
	double x;
	double y;
};

polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

#endif
```
```cpp
// file1.cpp

#include <iostream>
#include "coordin.h"
using namespace std;
int main()
{
	rect rplace;
	polar pplace;

	cout << "x값과 y값을 입력하십시오 : ";
	while (cin >> rplace.x >> rplace.y)
	{
		pplace = rect_to_polar(rplace);
		show_polar(pplace);
		cout << "x값과 y값을 입력하십시오(끝내려면 q를 입력) : ";
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}
```
```cpp
// file2.cpp

#include <iostream>
#include <cmath>
#include "coordin.h"

polar rect_to_polar(rect xypos)
{
	using namespace std;
	polar answer;

	answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
	answer.angle = std::atan2(xypos.y, xypos.x);
	return answer;
}

void show_polar(polar dapos)
{
	using namespace std;
	const double Rad_to_deg = 57.29577951;

	cout << "거리 = " << dapos.distance;
	cout << ", 각도 = " << dapos.angle * Rad_to_deg;
	cout << "도\n";
}
```

C++에서는 C와는 달리 헤더 파일을 빼고, 소스 코드 파일들만 컴파일함    
전처리기 지시자 `#ifndef`와 `#endif`를 이용하여 헤더 파일을 중복으로 포함시키는 실수를 방지함    

C++ 표준에서는 파일이라는 용어 대신 더 보편성이 큰 번역 단위(trnaslation unit)이라는 용어를 사용함    
컴파일러에 따라 이름 장식(혹은 이름 맹글링)의 방식이 다르기 때문에 서로 다른 컴파일러로 만들어진 목적 파일이나 라이브러리들은 링크시 에러가 발생할 가능성이 큼    


***
***


# 9.2 기억 존속 시간, 사용 범위, 링크
C++은 네가지 유형으로 데이터를 저장하며, 유형마다 데이터를 존속시키는 시간에서 차이가 발생함    
* 자동 기억 존속 시간(automatic storage duration) : 함수 매개변수 및 함수 정의 안에 선언된 변수는 자동 변수로써 자동 기억 존속 시간을 가짐    
	프로그램이 함수나 블록 안으로 들어갈 때 생성, 프로그램이 해당 함수나 블록을 떠나면 해제되며 C++은 두 종류의 자동 변수를 가짐    
* 정적 기억 존속 시간(static storage duration) : 함수 정의 바깥에서 정의된 변수 또는 `static`을 사용한 정적 변수는 정적 기억 존속 시간을 가짐    
	프로그램이 실행되는 전체 시간동안 존속하며, C++은 세 종류의 정적 변수를 가짐    
* 쓰레드 존속 시간(Thread Storage Duration(C++11) : 멀티코어 프로세스를 사용하여 연산 작업을 쓰레드 단위로 쪼개서 처리함    
* 동적 기억 존속 시간(dynamic storage duration) : `new`연산자를 사용하여 대입된 메모리는 동적 기억 존속 시간을 가지며, 이는 `delete`연산자로 해제되거나 프로그램이 종료할 때까지 존속됨    
	해당 메모리를 자유 공간(free stor)이라고 부르기도 함    

***

## 사용 범위와 링크

사용 범위(scope) : 어떠한 이름이 하나의 파일(혹은 번역 단위) 내에서 얼마나 널리 알려지는거나를 나타냄    
링크(linkage) : 서로 다른 번역 단위들이 이름을 공유하는 것
* 외부 링크(external linkage)를 가진 이름은 여러 파일들이 공유할 수 있음
* 내부 링크(internal linkage)를 가진 이름은 한 파일 안에 있는 함수들만 공유할 수 있음
* 자동 변수는 공유되지 않기 때문에 링크를 갖지 않음

C++ 변수는 종류에 따라 다른 사용 범위를 가짐    
* 지역 사용 범위(local scope) 또는 블록 사용 범위(block scope) : 해당 변수를 정의한 블록 안에만 알려짐
* 파일 사용 범위(file scope) 또는 전역 사용 범위(global scope) : 변수가 정의된 지점부터 그 아래로 파일 전체에 걸쳐 알려짐
* 함수 원형 사용 범위(function prototype scope) : 매개변수 리스트를 둘러싸고있는 괄호 안에만 알려짐
* 클래스 사용 범위(class scope) : 클래스 안에 선언된 멤버가 해당됨
* 이름 공간 사용 범위(namespace scope) : 어떠한 이름 공간 안에 선언된 변수가 해당되며, 전역 사용 범위는 이름 공간 사용 범위의 특별한 경우임    

C++의 함수는 다른 함수에 의해 호출되어야 하므로 지역 사용 범위는 가질 수 없음    

***

## 자동 변수

함수 매개변수 및 함수 안에서 선언된 변수는 기본적으로 자동 기억 존속 시간은 가짐     
* 지역 사용 범위를 가지며, 링크는 없음
* 각 변수는 프로그램이 해당 변수가 정의되어있는 블록에 들어갈 때 대입되며, 함수 종료시 메모리에서 사라짐
* 단, 사용 범위는 블록 내에서도 변수가 선언된 지점부터 시작됨

```cpp
// autoscp.cpp

#include <iostream>
void oil(int x);

int main()
{
	using namespace std;

	int texas = 31;
	int year = 2011;
	cout << "main()에서, texas = " << texas << ", &texas = ";
	cout << &texas << endl;
	cout << "main()에서, year = " << year << ", &year = ";
	cout << &year << endl;
	oil(texas);
	cout << "main()에서, texas = " << texas << ", &texas = ";
	cout << &texas << endl;
	cout << "main()에서, year = " << year << ", &year = ";
	cout << &year << endl;
	return 0;
}

void oil(int x)
{
	using namespace std;
	int texas = 5;

	cout << "oil()에서, texas = " << texas << ", &texas = ";
	cout << &texas << endl;
	cout << "oil()에서, x = " << x << ", &x = ";
	cout << &x << endl;
	{
		int texas = 113;
		cout << "블록에서, texas = " << texas << ", &texas = ";
		cout << &texas << endl;
		cout << "블록에서, x = " << x << ", &x = ";
		cout << &x << endl;
	}
	cout << "블록을 통과한 후, texas = " << texas;
	cout << ", &texas = " << &texas << endl;
}
```

블록의 앞뒤로 같은 이름의 변수가 있을 경우, 신규 정의가 이전 정의의 앞을 가려 이전 정의는 블록 안쪽에 있는 동안에는 사용되지 못함    

자동 변수는 그 선언에 도달된 시점에서 값을 알 수 있을 경우 어떠한 표현식을 사용하더라도 초기화할 수 있음    

C++컴파일러는 일반적으로 메모리의 일부를 예약해두고, 변수들의 생성과 소멸을 스택으로 관리함    
* 스택의 기본 크기는 상이하나 일반적으로 사용자가 선택할 수 있음
* 스택은 LIFO(후입선출) 설계로 매개변수의 전달 과정이 간단함
* 프로그램은 메모리의 시작 위치인 스택의 바닥을 지시하는 포인터와 비어있는 메모리 위치인 스택의 꼭대기를 지시하는 포인터를 사용하여 스택을 관리함
* 새로 생성되는 데이터는 먼저 생성된 데이터의 위에 쌓이고, 데이터 사용을 마치면 스택에서 제거됨
	* 정확히는 이미 입력된 데이터는 제거되지 않고, 대신 포인터가 데이터가 저장되기 이전의 위치로 돌아가 값을 덮어쓸 수 있도록 함    

기존의 C에서는 `register` 키워드로 컴파일러가 CPU 레지스터를 사용하여 자동 변수를 저장할 것을 요구했음    
그러나 C+11에서는 어떤 한 변수가 자동적임을 명시하는 용도로만 사용되며, 이는 `auto`를 사용하면 되기 때문에 기존 코드를 인식하기 위한 목적으만 사용됨    

***

## 정적 변수

