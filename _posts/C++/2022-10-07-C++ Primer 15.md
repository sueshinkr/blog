---
title:  "C++ Primer 15"
excerpt: "프렌드, 예외, 기타 사항"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.10.03 16:00:00
---

# 학습목표
* 프렌드 클래스
* 프렌드 클래스의 메소드
* 내포된 클래스
* 예외 처리, `try` 블록, `catch` 블록
* 예외 클래스
* RTTI(실행 시간 데이터형 정보)
* `dynamic_cast`와 `typeid`
* `static_cast`, `const_cast`, `reinterpret_cast`

***

# 15.1 프렌드

클래스도 프렌드가 될 수 있음    
* 프렌드 클래스의 모든 메소드는 오리지널 클래스의 `private` 멤버 및 `protected` 멤버에 접근할 수 있음    
* 어떤 클래스의 특정 멤버 함수들만 다른 클래스의 프렌드가 되도록 지정할 수 있음

## 프렌드 클래스

TV 클래스와 리모콘 클래스가 존재할때, 이 둘은 `is-a`도, `has-a` 관계도 아님    
그러나 리모콘 클래스는 TV 클래스의 상태를 변경할 수 있으며, 따라서 리모콘 클래스를 TV 클래스의 프렌드로 만들어야함    

```cpp
// tv.h

#ifndef TV_H_
#define TV_H_

class Tv
{
	public:
		friend class Remote;
		enum {Off, On};
		enum {MinVal, MaxVal = 20};
		enum {Antenna, Cable};
		enum {TV, DVD};

		Tv(int s = Off, int mc = 125) : state(s), volume(5),
			maxchannel(mc), channel(2), mode(Cable), input(TV) {}
		void onoff() { state = (state == On) ? Off : On; }
		bool ison() const { return state == On; }
		bool volup();
		bool voldown();
		void chanup();
		void chandown();
		void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }
		void set_input() { input = (input == TV ) ? DVD : TV; }
		void settings() const;

	private:
		int state;
		int volume;
		int maxchannel;
		int channel;
		int mode;
		int input;
};

class Remote
{
	private:
		int mode;
	public:
		Remote(int m = Tv::TV) : mode(m) {}
		bool volup(Tv & t) { return t.volup(); }
		bool voldown(Tv & t) { return t.voldown(); }
		void onfoff(Tv & t) { t.onoff(); }
		void chanup(Tv & t) { t.chanup(); }
		void chandown(Tv & t) { t.chandown(); }
		void set_chan(Tv & t, int c) { t.channel = c; }
		void set_mode(Tv & t) { t.set_mode(); }
		void set_input(Tv & t) { t.set_input(); }
};

#endif
```

```cpp
// tv.cpp

#include "tv.h"
#include <iostream>

bool Tv::volup()
{
	if (volume < MaxVal)
	{
		volume++;
		return true;
	}
	else
		return false;
}

bool Tv::voldown()
{
	if (volume > MinVal)
	{
		volume--;
		return true;
	}
	else
		return false;
}

void Tv::chanup()
{
	if (channel < maxchannel)
		channel++;
	else
		channel = 1;
}

void Tv::chandown()
{
	if (channel > 1)
		channel--;
	else
		channel = maxchannel;
}

void Tv::settings() const
{
	using std::cout;
	using std::endl;
	cout << "TV = " << (state == Off ? "OFF" : "ON") << endl;
	if (state == On)
	{
		cout << "볼륨 = " << volume << endl;
		cout << "채널 = " << channel << endl;
		cout << "모드 = " << (mode == Antenna ? "지상파 방송" : "케이블 방송") << endl;
		cout << "입력 = " << (input == TV ? "TV" : "DVD") << endl;
	}
}
```

```cpp
// use_tv.cpp

#include "tv.h"
#include <iostream>

int main()
{
	using std::cout;
	Tv s42;
	cout << "42\" TV의 초기 설정값:\n";
	s42.settings();
	s42.onoff();
	s42.chanup();
	cout << "\n42\" TV의 변경된 설정값 : \n";
	s42.settings();
	
	Remote grey;

	grey.set_chan(s42, 10);
	grey.volup(s42);
	grey.volup(s42);
	cout << "\n리모콘 사용 후 42\" TV의 설정값 : \n";
	s42.settings();

	Tv s58(Tv::On);
	s58.set_mode();
	grey.set_chan(s58, 28);
	cout << "\n58\" TV의 설정값 : \n";
	s58.settings();
	return 0;
}
```

`friend class Remote;`로 `Remote`를 `Tv` 클래스에 대한 프렌드 클래스로 선언함으로써 `Tv` 클래스의 `private` 부분들을 직접적으로 접근 가능함    

***

## 프렌드 멤버 함수

```cpp
class Tv
{
	friend void Remote::set_chan(Tv & t, int c);
	...
}'
```

`Remote` 클래스의 메소드들 중 `Tv` 클래스의 `private` 멤버에 직접 접근하는 메소드는 `Remote::set_chan()` 메소드 뿐임    
따라서 클래스 전체를 프렌드로 만드는 대신 해당 메소드만 클래스에 대한 프렌드로 만드는 것이 가능함    
단, 이 경우 컴파일러가 `Remote`의 정의를 미리 알고있어야 하지만 `Remote`는 `Tv` 객체를 사용하기 때문에 `Tv`의 정의가 `Remote` 앞에 나타나야함    
이러한 순환 종속을 피하기 위해 아래와 같이 사전 선언(forward declaration)을 사용함    

```cpp
class Tv;
class Remote { ... };
class Tv { ... };
```

`Tv`와 `Remote`의 순서를 반대로 할 경우 에러가 발생함    
이는 `Tv` 클래스 선언시 `Remote` 메소드가 프렌드로 선언되어있기 때문에 반드시 `Remote` 클래스의 `set_Chan()` 메소드에 대해 알고있어야 하기 때문    

```cpp
// tvfm.h

#ifndef XXX_H_
#define XXX_H_

class Tv;

class Remote
{
	public:
		enum State{Off, On};
		enum {MinVal, MaxVal = 20};
		enum {Antenna, Cable};
		enum {TV, DVD};
	private:
		int mode;
	public:
		Remote(int m = TV) : mode(m) {}
		bool volup(Tv & t);
		bool voldown(Tv & t);
		void onfoff(Tv & t);
		void chanup(Tv & t);
		void chandown(Tv & t);
		void set_chan(Tv & t, int c);
		void set_mode(Tv & t);
		void set_input(Tv & t);
};

class Tv
{
	public:
		friend void Remote::set_chan(Tv & t, int c);
		enum State{Off, On};
		enum {MinVal, MaxVal = 20};
		enum {Antenna, Cable};
		enum {TV, DVD};

		Tv(int s = Off, int mc = 125) : state(s), volume(5),
			maxchannel(mc), channel(2), mode(Cable), input(TV) {}
		void onoff() { state = (state == On) ? Off : On; }
		bool ison() const { return state == On; }
		bool volup();
		bool voldown();
		void chanup();
		void chandown();
		void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }
		void set_input() { input = (input == TV ) ? DVD : TV; }
		void settings() const;

	private:
		int state;
		int volume;
		int maxchannel;
		int channel;
		int mode;
		int input;
};

inline bool Remote::volup(Tv & t) { return t.volup(); }
inline bool Remote::voldown(Tv & t) { return t.voldown(); }
inline void Remote::onfoff(Tv & t) { t.onoff(); }
inline void Remote::chanup(Tv & t) { t.chanup(); }
inline void Remote::chandown(Tv & t) { t.chandown(); }
inline void Remote::set_chan(Tv & t, int c) { t.channel = c; }
inline void Remote::set_mode(Tv & t) { t.set_mode(); }
inline void Remote::set_input(Tv & t) { t.set_input(); }
#endif
```

인라인 함수들은 내부 링크를 가지기 때문에 함수를 사용하는 파일 안에 함수 정의가 들어있어야함    
`inline` 키워드를 제거하여 외부 링크를 갖게할 경우 함수 정의를 구현 파일에 넣을 수도 있음    

***

## 그 밖의 프렌드 관계

```cpp
class Tv
{
	friend class Remote;
	public:
		void buzz(Remote & r);
		...
};

class Remote
{
	friend class Tv;
	public:
		void bool volup(Tv & t) { t.volup(); }
		...
};

inline void Tv:buzz(Remote & r) { ... }
```

클래스들을 상호 프렌드(mutual friend) 관계로 설정할 수 있음    
`Remote` 객체를 사용하는 `Tv`의 메소드인 `Tv::buzz()`의 경우 원형은 `Remote` 클래스 선언 앞에 둘 수 있으나 정의는 뒤에 두어야함    
`Tv` 객체를 사용하는 `Remote::volup()` 메소드의 경우 `Tv` 클래스 선언 뒤에 등장하기 때문에 클래스 선언 안에서 곧바로 정의 가능함    

***

## 공유 프렌드

```cpp
class Analyzer;
class Probe
{
	friend void sync(Analyzer & a, const Probe & p);
	friend void sync(Probe & p, const Analyzer & a);
	...
};

class Analyzer
{
	friend void sync(Analyzer & a, const Probe & p);
	friend void sync(Probe & p, const Analyzer & a);
	...
};

inline void sync(Analyzer & a, const Probe & p) { ... }
inline void sync(Probe & p, const Analyzer & a) { ... }
```

하나의 함수가 서로 다른 두 클래스에 들어있는 `private` 데이터에 접근해야 할 경우, 해당 함수는 각 클래스의 멤버 함수여야하지만 이는 불가능함    
따라서 한 클래스의 멤버잉자 다른 클래스에 대해서 프렌드로 만들 수 있으나 두 클래스 모두에 대해 프렌드로 만들 수도 있음    


***
***


# 15.2 내포 클래스

클래스 안에 선언된 클래스를 내포 클래스(nested class)라고함    
클래스 선언을 내포하고있는 클래스의 멤버 함수들은 내포 클래스의 객체들을 생성하여 사용할 수 있음    
클래스 외부에서는 내포 클래스 선언이 `public` 부분이 들어있고, 사용 범위 결정 연산자를 사용했을 경우에만 내포 클래스를 사용할 수 있음    

다른 클래스의 객체를 클래스의 멤버로 가지는 컨테인먼트와는 다름    
클래스를 내포시킬시엔 클래스 멤버가 생성되지 않고, 대신 클래스 선언을 내포하고잇는 클래스에만 지역적으로 알려지는 하나의 데이터형을 정의함    

```cpp
class Queue
{
	class Node
	{
		public:
			Item item;
			Node * next;
			Node(const Item & i) : item(i), next(0) {}
	};
	...
};

boll Queue::enqueue(const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node(item);
	...
}
```

`Node` 객체는 `Queue::enqueue()` 메소드에서 유일하게 생성함    
`Node`의 생성자를 클래스 선언이 아닌 메소드 정의 파일에 정의하고싶다면 `Node` 클래스가 `Queue` 클래스 내부에 정의된다는 사실을 반영해야함    
즉, `Queue::Node::Node(const Item & i) : item(i), next(0) {}`의 형태로 사용해야함    

***

## 내포 클래스와 접근

내포 클래스가 선언된 장소가 내포 클래스의 사용 범위 즉, 프로그램의 어느 부분에서 내포 클래스의 객체를 생성할 수 있는지를 결정함    
내포 클래스의 `public`, `protected`, `private` 부분이 해당 클래스 멤버에 대한 접근을 제한함    

내포 클래스가 제2 클래스의 `private` 부분에 선언될 경우
* 해당 클래스 외부에서는 내포 클래스가 존재한다는 사실조차 알지 못함    
* 파생 클래스에서도 기초 클래스의 `private` 부분에 직접 접근할 수 없기 때문에 내포 클래스가 보이지 않음

내포 클래스가 제2 클래스의 `protected` 부분에 선언될 경우
* 해당 클래스 외부에서는 보이지 않음
* 파생 클래스에서는 내포 클래스가 보이며, 내포 클래스형의 객체를 직접 생성할 수 있음

내포 클래스가 제2 클래스의 `public` 부분에 선언될 경우
* `public`이므로 해당 클래스 외부에서 사용할 수 있음
* 단, 클래스 사용 범위가 있으므로 외부에서 사용시엔 클래스 제한자를 사용해야함

클래스가 선언된 장소가 클래스의 사용 범위 또는 가시 범위를 결정함    
어떤 특정 클래스가 사용 범위에 들어올 경우 일반적인 접근 제어 규칙(`public`, `protected`, `private`, `friend`)이 내포 클래스의 멤버들에 대한 접근 가능 여부를 결정함    

***

## 템플릿에서의 내포

```cpp
// queuetp.h

#ifndef QUEUETP_H_
#define QUEUETP_H_

template<class Item>
class QueueTP
{
	private:
		enum {Q_SIZE = 10};
		class Node
		{
			public:
				Item item;
				Node * next;
				Node(const Item & i) : item(i), next(0) {}
		};
		Node * front;
		Node * rear;
		int items;
		const int qsize;
		QueueTP(const QueueTP & q) : qsize(0) {}
		QueueTP & operator=(const QueueTP & q) { return *this; }
	public:
		QueueTP(int qs = Q_SIZE);
		~QueueTP();
		bool isempty() const { return items == 0; }
		bool isfull() const { return items == qsize; }
		int queuecount() const { return items; }
		bool enqueue(const Item & item);
		bool dequeue(Item & item);
};

template <class Item>
QueueTP<Item>::QueueTP(int qs) : qsize(qs)
{
	front = rear = 0;
	items = 0;
}

template <class Item>
QueueTP<Item>::~QueueTP()
{
	Node * temp;
	while (front != 0)
	{
		temp = front;
		front = front->next;
		delete temp;
	}
}

template <class Item>
bool QueueTP<Item>::enqueue(const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node(item);
	items++;
	if (front == 0)
		front = add;
	else
		rear->next = add;
	rear = add;
	return true;
}

template <class Item>
bool QueueTP<Item>::dequeue(Item & item)
{
	if (front == 0)
		return false;
	item = front->item;
	items--;
	Node * temp = front;
	front = front->next;
	delete temp;
	if (items == 0)
		rear = 0;
	return true;
}

#endif
```

```cpp
// nested.cpp

#include "queuetp.h"
#include <iostream>
#include <string>

int main()
{
	using std::string;
	using std::cin;
	using std::cout;

	QueueTP<string> cs(5);
	string temp;

	while (!cs.isfull())
	{
		cout << "이름을 입력하십시오. 도착하신 순서대로 사은품을 드립니다.\n"
			 << "이름 : ";
		getline(cin, temp);
		cs.enqueue(temp);
	}
	cout << "큐가 가득 찼으므로, 지금부터 사은품을 나누어 드리겠습니다.\n";
	while (!cs.isempty())
	{
		cs.dequeue(temp);
		cout << temp << " 님! 감사합니다. 안녕히 가십시오.\n";
	}
	return 0;
}
```

클래스 템플릿을 사용하는 경우에도 내포 클래스의 사용은 아무런 문제를 발생시키지 않음    


***
***


# 15.3 예외

사용할 수 없는 파일을 열려고 시도하거나, 사용가능한 메모리보다 더 많은 양의 메모리를 요구하거나, 처리할 수 없는 값들을 만날 경우 정상적으로 실행을 계속할 수 없는 상황에 직면함    
C++의 예외(exception)은 이러한 상황을 처리하기 위하여 도구를 제공함    

## abort() 호출

```cpp
// error1.cpp

#include <iostream>
#include <cstdlib>

double hmean(double a, double b);

int main()
{
	double x, y, z;

	std::cout << "두 수를 입력하십시오 : ";
	while (std::cin >> x >> y)
	{
		z = hmean(x, y);
		std::cout << x << ", " << y << "의 조화평균은 "
				  << z << "입니다.\n";
		std::cout << "다른 두 수를 입력하십시오(끝내려면 q) : ";
	}
	std::cout << "프로그램을 종료합니다.\n";
	return 0;
}

double hmean(double a, double b)
{
	if (a == -b)
	{
		std::cout << "매개변수들을 hmean()에 전달할 수 없습니다.\n";
		std::abort();
	}
	return 2.0 * a * b / (a + b);
}
```

0으로 나누기가 발생한 경우 `abort()` 함수를 호출하여 문제를 해결할 수 있음    ㄴ
* `abort()` 함수의 원형은 `cstdlib` 헤더 파일에 포함
* 호출될시 표준 에러 스트림에 "abnormal program termination(비정상적인 프로그램 종료)" 등의 메시지를 보내고 프로그램을 종료시킴
* 프로그램을 기동시킨 부모 프로세스나 운영체제의 컴파일러에 종속적인 어떤 값을 리턴함
* 파일 버퍼를 비우는지의 여부는 시스템마다 다를 수 있으며, 메세지 출력 없이 파일 버퍼만 비우고싶은 경우 `exit()`를 사용

***

## 에러 코드 리턴

```cpp
// error2.cpp

#include <iostream>
#include <cfloat>

bool hmean(double a, double b, double * ans);

int main()
{
	double x, y, z;

	std::cout << "두 수를 입력하십시오 : ";
	while (std::cin >> x >> y)
	{
		if (hmean(x, y, &z))
			std::cout << x << ", " << y << "의 조화평균은 "
				  << z << "입니다.\n";
		else
			std::cout << "서로 부정인 두 수의 조화평균은 구할 수 없습니다.\n";
		std::cout << "다른 두 수를 입력하십시오(끝내려면 q) : ";
	}
	std::cout << "프로그램을 종료합니다.\n";
	return 0;
}

bool hmean(double a, double b, double * ans)
{
	if (a == -b)
	{
		*ans = DBL_MAX;
		return false;
	}
	else
	{
		*ans = 2.0 * a * b / (a + b);
		return true;
	}
}
```

프로그램의 비정상 종료보다 함수의 리턴값을 사용하여 어떤 문제가 발생했는지를 알리는것이 유용함    
즉, 위와 같이 에러 상황이 발생한경우 프로그램을 바로 종료하는 대신 `bool`형 함수의 리턴값으로 해당 상황을 알릴 수 있음    
전통적인 C에서는 리턴 조건을 전역변수 `errno`를 사용하여 활용함    

***

## 예외 메커니즘

C++의 예외 처리는 다음과 같은 단계로 이루어짐
* 예외를 발생시킴
* 핸들러를 사용하여 예외를 포착
* `try` 블록을 사용

예외 발생시 다른 위치에있는 구문으로 프로그램의 제어를 넘김    
`throw` 키워드가 예외의 발생을 나타내며, 그 뒤에는 예외의 특징을 나타내는 하나의 값이 뒤따름    

프로그램은 문제 해결을 원하는 장소에서 예외 핸들러(exception handler)를 사용하여 예외를 포착함    
`catch` 키워드가 예외의 포착을 나타매녀, 그 뒤에는 예외 핸들러가 취할 조치들을 나타내는 코드 블록이 중괄호로 묶여 나타남    

`try` 블록은 특별한 예외들이 발생할 수 있는 하나의 코드 블록으로, 그 뒤에는 하나 이상의 `catch` 블록이 등장함    

```cpp
// error3.cpp

#include <iostream>

double hmean(double a, double b);

int main()
{
	double x, y, z;

	std::cout << "두 수를 입력하십시오 : ";
	while (std::cin >> x >> y)
	{
		try {
				z = hmean(x, y);
		}
		catch (const char * s)
		{
			std::cout << s << std::endl;
			std::cout << "두 수를 새로 입력하십시오 : ";
			continue;
		}
		std::cout << x << ", " << y << "의 조화평균은 "
				  << z << "입니다.\n";
		std::cout << "다른 두 수를 입력하십시오(끝내려면 q) : ";
	}
	std::cout << "프로그램을 종료합니다.\n";
	return 0;
}

double hmean(double a, double b)
{
	if (a == -b)
		throw "잘못된 hmean() 매개변수 : a = -b 는 허용되지 않습니다.";
	return 2.0 * a * b / (a + b);
}
```

`try` 블록 내의 구문이 예외를 발생시킬경우 `catch` 블록에서 해당 예외를 처리함    
위에서는 예외 발생이 문자열로 이루어져있으나, 클래스형이 일반적인 선택임    
`try` 블록에서 예외 발생을 감지했을시 발생된 예외의 데이터형(여기서는 문자열)과 일치하는 예외 핸들러(`catch` 블록)를 찾아 실행함    
예외가 발생하지 않고 `try` 블록 내의 구문들의 실행이 완수된다면 `catch` 블록을 건너뛰어 그 다음 구문으로 넘어감    

함수에서 예외 발생시 `try` 블록이 없거나 데이터형이 일치하는 예외 핸들러가 없을 경우 프로그램은 기본적으로 `abort()` 함수를 호출함    
이 행동은 사용자가 수정할 수 있음    

***

## 예외로 객체 사용하기

일반적으로 예외를 발생시키는 함수들은 객체를 발생시킴    
* 서로 다른 예외 데이터형을 사용함으로써 서로 다른 함수들과 예외를 발생시키는 상황을 구별할 수 있음
* 객체 자체에 정보를 전달할 수 있으며, 이를 사용하여 예외가 발생하는 여러 조건들을 식별할 수 있음