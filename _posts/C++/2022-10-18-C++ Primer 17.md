---
title:  "C++ Primer 17"
excerpt: "입력, 출력, 파일"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.10.17 14:00:00
---

# 학습목표
* C++에서의 입출력
* `iostream` 계열의 클래스
* 리디렉션
* `ostream` 클래스 메소드
* 출력 형식 지정
* `istream` 클래스 메소드
* 스트림의 상태
* 파일 입출력
* 파일로부터 입력을 얻는 `ifstream` 클래스
* 파일에 출력을 하는 `ofstream` 클래스
* 파일 입출력을 위한 `fstream` 클래스
* 명령행 처리
* 2진 파일
* 파일 임의 접근
* 인코어 형식 지정

***

# 17.1 C++ 입출력의 개요

C++에서도 `cstdio` 헤더 파일을 통해 입출력에 사용하는 일반적인 C 함수들을 사용할 수 있음    
C++ 스타일의 입출력은 `iostream`, `fstream` 헤더 파일에 정의되어있는 클래스들의 집합을 사용함    

## 스트림과 버퍼

C++에서는 입력과 출력을 바이트들의 흐름인 스트림으로 간주함   
* 입력시 입력 스트림으로 바이트들을 추출, 출력시 출력 스트림에 바이트들을 삽입    
* 바이트들은 수치 데이터 또는 문자의 2진 표현을 나타낼 수 있음    
* 입력 스트림의 바이트들은 키보드 / 저장자치 / 다른 프로그램으로부터 흘러나올 수 있음    
* 출력 스트림의 바이트들은 디스플레이 / 프린터 / 저장장치 / 다른 프로그램으로 흘러나갈 수 있음    

입력을 다루기 위해선 두가지 절차가 필요
* 하나의 스트림을 프로그램의 입력에 연결
* 스트림을 하나의 파일에 연결
* 즉, 입력 스트림은 양쪽에 하나씩 두개의 연결을 필요로함    

버퍼 이용시 입력과 출력을 더 효율적으로 처리할 수 있음   
* 버퍼(buffer) : 정보를 전송하기 위해 임시 저장장치로 사용하는 메모리 블록
* 저장장치와 프로그램의 정보 전송률 차이를 극복할 수 있도록 도와줌
	* 우선 버퍼에 한꺼번에 많은 데이터를 읽어들여 저장한 후, 이후 프로그램이 버퍼로부터 데이터를 읽어들임
	* 출력시 버퍼를 가득 채운 다음 전송하고, 이후 버퍼를 깨끗하게 비우는 버퍼 비우기(flushing the buffer)를 수행함    
	* 일반적으로 사용자가 `Enter`를 누를때 입력 버퍼를 비우고, 개행 문자를 전달받으면 출력 버퍼를 비움    
***

## 스트림, 버퍼, iostream 파일

C++에서의 입출력 클래스
* `streambuf` 클래스 : 버퍼로 사용할 메모리 제공, 버퍼 채우기, 버퍼 접근, 버퍼 비우기 등 버퍼 메모리를 관리하는 클래스 메소드 제공
* `ios_base` 클래스 : 스트림의 일반적인 특성들을 나타냄
* `ios` 클래스 : `ios_base` 클래스에 기초하며 `streambuf` 객체를 지시하는 포인터 멤버를 가짐
* `ostream` 클래스 : `ios` 클래스에서 파생되어 출력 메소드들을 제공
* `istream` 클래스 : `ios` 클래스에서 파생되어 입력 메소드들을 제공
* `iostream` 클래스 : `istream` 클래스와 `ostream` 클래스에 기초하여 입력 메소드들과 출력 메소드들을 모두 상속받음

프로그램에 `iostream` 파일 포함시 자동으로 8개의 스트림 객체가 생성됨
* `cin` : 표준 입력 스트림에 해당, 키보드 등의 표준 입력 장치에 연결됨
* `cout` : 표준 출력 스트림에 해당, 모니터 등의 표준 출력 장치에 연결됨
* `cerr` : 표준 에러 스트림에 해당, 표준 출력 장치에 연결되나 버퍼를 사용하지 않기 때문에 곧바로 출력됨
* `clog` : 표준 에러 스트림에 해당, 표준 출력 장치에 연결되며 버퍼를 사용함
* `wcin`, `wcout`, `wcerr`, `wclog` : `wchar_t` 형에 동작

스트림이 해당하는 객체 생성시 해당 객체는 입력 또는 출력과 관련된 모든 정보를 담고있는 데이터 멤버들을 가지게됨    

***

## 리디렉션

리디렉션(redirection) : 표준 입력과 표준 출력을 위한 연결을 다른쪽으로 변경    
	많은 운영체제들이 리디렉션 기능을 지원함    

`cout`으로 나타나는 표준 출력 스트림, `cerr`와 `clog`로 나타나는 표준 에러 스트림의 객체들은 모두 모니터로 보내짐   
표준 출력을 리디렉션하는 것은 `cerr`와 `clog`에 영향을 주지 않기 때문에 `cout` 출력이 다른 곳으로 리디렉션되어있는 경우에도 에러 메시지를 화면에 출력함    
운영체제에 따라 표준 에러를 리디렉션할 수 있는 경우도 있음    


***
***


# 17.2 cout을 이용한 출력

`ostream` 클래스는 `int`나 `float`와 같은 수치 데이터를 문자들의 스트림으로 변환함    
즉, 2진 비트 패턴으로 되어있는 수치 데이터의 내부적인 표현을 문자 바이트의 스트림으로 변환함    

## 오버로딩된 << 연산자

`ostream` 클래스는 오버로딩을 통해 기본적으로 왼쪽 시프트 연산자로 사용되는 `<<` 연산자를 `ostream` 클래스에 대한 출력으로 재정의함    
* 이 경우의 `<<` 연산자는 삽입 연산자라고 부름
* 삽입 연산자는 C++의 모든 기본 데이터형들을 인식할 수 있도록 오버로딩되어있음
* 각각의 데이터형들에 대해 `operator<<()` 함수 정의를 제공함    

`ostream` 클래스는 포인터형을 위한 삽입 연산자 함수들도 정의함
* `const signed char *`, `const unsigned char *`, `const char *`, `void *`
* 따라서 `char * pn = "abc"; cout << pn;` 구문은 정상적으로 작동함    
* 다른 데이터형을 지시할 경우 포인터를 `void *`형에 일치시킨 후 그 주소의 수치적 표현을 출력함    

모든 삽입 연산자 함수들은 `ostream &`형을 리턴하도록 정의되어있음
* 리턴하는 참조는 연산자를 호출한 객체에 대한 참조임
* 따라서 이를 이용하여 출력을 연이어 할 수 있음

***

## 그 밖의 ostream 메소드들

`ostream` 클래스는 문자들을 화면에 출력하는 `put()` 메소드와 `write()` 메소드를 제공함    
* `put()` 메소드도 호출한 객체에 대한 참조를 리턴하므로 연이어 출력할 수 있음
* `put()` 메소드에 적절한 수치형 매개변수 사용시 `char`형 값으로 변환하여 사용됨    
* `write()` 메소드는 전체 문자열을 출력하며, 첫번째 매개변수로 출력할 문자열의 주소를 받고 두번째 매개변수로 출력할 문자들의 수를 받음

```cpp
// write.cpp

#include <iostream>
#include <cstring>

int main()
{
	using std::cout;
	using std::endl;
	const char * state1 = "Florida";
	const char * state2 = "Kansas";
	const char * state3 = "Euphoria";
	int len = std::strlen(state2);

	cout << "루프 인덱스 증가 : \n";
	int i;
	for (i = 1; i <= len; i++)
	{
		cout.write(state2, i);
		cout << endl;
	}

	cout << "루프 인덱스 감소 : \n";
	for (i = len; i > 0; i--)
		cout.write(state2, i) << endl;
	
	cout << "문자열 길이 초과 : \n";
	cout.write(state2, len + 5) << endl;

	return 0;
}
```

`cout.write()` 호출은 그것을 호출한 객체에 대한 참조를 리턴함    
`write()` 메소드는 널문자에 도달하더라도 출력을 자동으로 멈추지 않음    
`write()` 메소드는 수치 데이터에도 사용할 수 있으며, 따라서 `char *`형으로 캐스트한 어떤 수의 주소를 전달할 수 있음    
* 이 때 수치를 값에 해당하는 문자로 변환하는 것이 아니라 메모리에 저장된 비트 표현을 그대로 전달함
* 수치 데이터를 가장 간결하고 정확하게 파일에 저장하는 방법을 제공함

***

## 출력 버퍼 비우기

`cout` 객체가 다루는 출력에는 버퍼를 사용하므로 출력은 버퍼가 가득 찰 때까지 쌓임    
이후 버퍼의 내용을 목적지로 보내고 새로운 데이터 저장을 위해 버퍼를 깨끗하게 배움    
단, 메모리 낭비를 방지하기 위해 개행 문자를 보낼시 버퍼가 자동으로 비워짐    
긴급 입력을 받아들여야할 때도 버퍼를 비우기 때문에 문자열에 개행 문자가 들어있지 않더라도 그 뒤의 입력을 예상하여 문자열을 즉시 출력할 수 있음    

사용자가 원하는 때에 출력이 되지 않을시 조정자(manipulator)를 사용하여 강제로 출력할 수 있음
* `flush` : 버퍼를 비움
* `endl` : 버퍼를 비우고 개행 문자를 삽입함
* 조정자들은 실제로는 `<<` 연산자로 오버로딩되는 함수이기 때문에 직접 호출하는 것도 가능함    

***

## cout을 이용한 출력 형식 지정

`ostream` 삽입 연산자는 값들을 텍스트 형식으로 변환함    
* 인쇄할 수 있는 문자에 해당하는 `char`형 값은 한 문자 필드 폭에 해당 문자를 출력함
* 수치 정수형은 알맞은 크기의 필드 폭에 십진수 형식으로 출력하며, 음수인 경우 마이너스 부호도 함께 출력함
* 문자열은 해당 문자열 길이에 맞는 크기의 필드폭에 출력함
* 부동 소수점형은 총 6자리에 출력되며 뒤에 붙는 0들은 출력되지 않고, 지수가 6 이상이거나 -5 이하면 E 표기가 사용됨

```cpp
// defaults.cpp

#include <iostream>

int main()
{
	using std::cout;
	cout << "12345678901234567890\n";
	char ch = 'K';
	int t = 273;
	cout << ch << " : \n";
	cout << t << " : \n";
	cout << -t << " : \n";

	double f1 = 1.200;
	cout << f1 << " : \n";
	cout << (f1 + 1.0 / 9.0) << " : \n";

	double f2 = 1.67E2;
	cout << f2 << " : \n";
	f2 += 1.0 / 9.0;
	cout << f2 << " : \n";
	cout << (f2 * 1.0e4) << " : \n";
  
	double f3 = 2.3e-4;
	cout << f3 << " : \n";
	cout << f3 / 10 << " : \n";

	return 0;
}
```

### 화면 출력을 위한 진법 변경

조정자를 사용하여 화면에 정수를 출력할 때 사용되는 진법을 제어할 수 있음    
출력 상태를 서술하는 정보를 가지고 있는 `ios_base`의 멤버 함수를 사용하여 필드 폭과 소수점 아래 자릿수를 제어할 수 있음    

```cpp
// manip.cpp

#include <iostream>

int main()
{
	using namespace std;
	cout << "하나의 정수를 입력하십시오 : ";
	int n;
	cin >> n;

	cout << "n\tn*n\n";
	cout << n << "\t" << n*n << " (10진법)\n";

	cout << hex;
	cout << n << "\t";
	cout << n*n << " (16진법)\n";

	cout << oct << n << "\t" << n*n << " (8진법)\n";

	dec(cout);
	cout << n << "\t" << n*n << " (10진법)\n";

	return 0;
}
```

### 필드 폭 조정

`width()` 멤버 함수를 사용하여 서로 다른 크기의 수들을 동일한 필드 폭에 출력할 수 있음    
* `int width();`의 경우 현재 설정된 필드 폭을 리턴함
* `int width(int i);`의 경우 현재 필드 폭을 i칸으로 설정하고 이전의 필드 폭을 리턴함
* 바로 다음에 출력될 항목에만 영향을 미친 후 해당 항목을 지나가면 디폴트 값으로 환원됨    

```cpp
// width.cpp

#include <iostream>

int main()
{
	using std::cout;
	int w = cout.width(30);
	cout << "디폴트 필드 폭 = " << w << " : \n";

	cout.width(5);
	cout << "N" << ':';
	cout.width(8);
	cout << "N * N" << ":\n";

	for (long i = 1; i <= 100; i *= 10)
	{
		cout.width(5);
		cout << i << ':';
		cout.width(8);
		cout << i*i << " : \n";
	}

	return 0;
}
```

### 채움 문자

기본적으로 `cout`은 필드 폭의 남는 부분을 빈칸으로 채우며, `fill()`멤버 함수를 사용하면 다른 것으로 바꿀 수 있음    

```cpp
// fill.cpp

#include <iostream>

int main()
{
	using std::cout;
	cout.fill('*');
	const char * staff[2] = {"윤성일", "박순용"};
	long bonus[2] = {900, 1350};

	for (int i = 0; i < 2; i++)
	{
		cout << staff[i] << " : $";
		cout.width(7);
		cout << bonus[i] << "\n";
	}

	return 0;
}
```

### 부동 소수점수의 출력 정밀도 설정

부동 소수점수의 정밀도의 경우
* 디폴트 모드에서는 출력되는 총 자릿수를 의미
* 고정 소수점 표기 또는 지수 표기 모드에서는 소수점 아래 자릿수를 의미
* `precision()` 이라는 멤버 함수를 사용하여 정밀도를 다르게 설정할 수 있음

```cpp
// precise.cpp

#include <iostream>

int main()
{
	using std::cout;
	float price1 = 20.40;
	float price2 = 1.9 + 8.0 / 9.0;

	cout << "\"손오공 인형\" $" << price1 << "!\n";
	cout << "\"사오정 인형\" $" << price2 << "!\n";

	cout.precision(2);
	cout << "\"손오공 인형\" $" << price1 << "!\n";
	cout << "\"사오정 인형\" $" << price2 << "!\n";

	return 0;
}
```

### 뒤에 붙는 0과 소수점 출력

`ios_base` 클래스의 `setf()`함수에서 여러가지 설정이 가능함     
`ios_base::showpoint`는 `cout`이 뒤에 붙는 소수점을 출력하도록 만들며, 디폴트 부동 소수점 형식에서 뒤에 붙는 0들도 출력하게 만듬    

```cpp
// showpt.cpp

#include <iostream>

int main()
{
	using std::cout;
	using std::ios_base;

	float price1 = 20.40;
	float price2 = 1.9 + 8.0 / 9.0;

	cout.setf(ios_base::showpoint);
	cout << "\"손오공 인형\" $" << price1 << "!\n";
	cout << "\"사오정 인형\" $" << price2 << "!\n";

	cout.precision(2);
	cout << "\"손오공 인형\" $" << price1 << "!\n";
	cout << "\"사오정 인형\" $" << price2 << "!\n";

	return 0;
}
```

### setf()에 대한 보충

`setf()`가 정의되어있는 `ios_base` 클래스는 하나의 `protected` 멤버를 가지고있으며, 해당 멤버의 각 비트들은 진법이나 뒤에붙는 0들의 출력 여부 등을 제어함    
이 비트들을 키는 것(=1로 설정)을 플래그를 설정한다고 함    

첫번째 원형은 `fmtflags setf(fmtflags);`의 형태를 가지며, `fmtflags`는 출력 형식 플래그를 보관하는데 사용되는 비트마스크(bitmask) 데이터형의 `typedef` 이름으로 `ios_base`에 정의되어있음
* 매개변수는 설정할 비트를 나타내며, 모든 플래그들이 이전 설정값을 나타내는 `fmtflags`형 수를 리턴함
* `boolalpha`, `showbase`, `showpoint`, `uppercase`, `showpos` 등의 지정 상수들이 존재함    
* 출력 형식 지정 상수들은 `ios_base` 클래스에 정의되어있으므로 사용 범위 결정 연산자와 함께 사용해야함    

```cpp
// setf.cpp

#include <iostream>

int main()
{
	using std::cout;
	using std::endl;
	using std::ios_base;

	int temperature = 63;

	cout << "오늘의 수온 : ";
	cout.setf(ios_base::showpos);
	cout << temperature << endl;

	cout << "프로그래머들에게 그 값은\n";
	cout << std::hex << temperature << endl;
	cout.setf(ios_base::uppercase);
	cout.setf(ios_base::showbase);
	cout << "또는\n";
	cout << temperature << endl;
	cout << true << "!의 값은 ";
	cout.setf(ios_base::boolalpha);
	cout << true << "이다.\n";

	return 0;
}
```

두번째 원형은 `fmtflags setf(fmtflags, fmtflags);`의 형태를 가짐
* 첫번째 매개변수는 원하는 설정이 담긴 `fmtflags` 값을 사용
* 두번째 매개변수는 해당 비트들을 먼저 깨끗하게 지우는 값을 사용
	* `basefield` - 진법 변경, `floatfield` - 표기 변경, `adjustfield` - 정렬 변경

```cpp
// setf2.cpp

#include <iostream>
#include <cmath>

int main()
{
	using namespace std;

	cout.setf(ios_base::left, ios_base::adjustfield);
	cout.setf(ios_base::showpos);
	cout.setf(ios_base::showpoint);
	cout.precision(3);

	ios_base::fmtflags old = cout.setf(ios_base::scientific, ios_base::floatfield);
	cout << "왼쪽 정렬 : \n";
	long n;
	for (n = 1; n <= 41; n += 10)
	{
		cout.width(4);
		cout << n << "|";
		cout.width(12);
		cout << sqrt(double(n)) << "|\n";
	}

	cout.setf(ios_base::internal, ios_base::adjustfield);
	cout.setf(old, ios_base::floatfield);
	cout << "내부(internal) 정렬 : \n";
	for (n = 1; n <= 41; n += 10)
	{
		cout.width(4);
		cout << n << "|";
		cout.width(12);
		cout << sqrt(double(n)) << "|\n";
	}

	cout.setf(ios_base::right, ios_base::adjustfield);
	cout.setf(ios_base::fixed, ios_base::floatfield);
	cout << "오른쪽 정렬 : \n";
	for (n = 1; n <= 41; n += 10)
	{
		cout.width(4);
		cout << n << "|";
		cout.width(12);
		cout << sqrt(double(n)) << "|\n";
	}

	return 0;
}
```

`setf()`의 효과는 `unsetf()`를 호출하여 취소시킬 수 있음    
* `void unsetf(fmtflags mask);` 형태의 원형을 가짐
* `mask`는 하나의 비트 패턴으로 `mask`에 1로 설정되어있는 모든 비트들이 해당 비트들의 설정을 해제하여 0으로 만듬    
* `ccout.setf(0, ios_base::floatfield);`와 `cout.unsetf(ios_base::floatfield);`는 동일함

### 표준 조정자

C++은 `setf()`를 호출하는 몇가지 조정자를 제공하여 정확한 매개변수를 자동으로 호출함    
* `boolalpha`, `noboolalpha`
* `showbase`, `noshowbase`
* `showpoint`, `noshowpoint`
* `showpos`, `noshowpos`
* `uppercase`, `nouppercase`
* `internal`, `left`, `right`
* `dec`, `hex`, `oct`
* `fixed`, `scientific`

### iomanip 헤더 파일

출력 형식 지정시 `iostream`의 도구들은 번거로울 수 있기 때문에, `iomanip` 헤더파일 안에 조정자들을 제공함    
* `setprecision()`, `setfill()`, `setw()` 함수 등이 있음
* 매개변수를 사용하며, `cout` 구문에 연결하여 사용할 수 있음

```cpp
// iomanip.cpp

#include <iostream>
#include <iomanip>
#include <cmath>

int main()
{
	using namespace std;
	cout << fixed << right;

	cout << setw(6) << "N" << setw(14) << "제곱근"
		 << setw(15) << "네제곱근\n";
	
	double root;
	for (int n = 10; n <= 100; n += 10)
	{
		root = sqrt(double(n));
		cout << setw(6) << setfill('.') << n << setfill(' ')
			 << setw(12) << setprecision(3) << root
			 << setw(14) << setprecision(4) << sqrt(root)
			 << endl;
	}

	return 0;
}
```


***
***


# 17.3 cin을 이용한 입력