---
title:  "C++ Primer 07"
excerpt: "C++의 프로그래밍 모듈"

categories:
  - Cpp
tags:
  - [C++]
toc: true
toc_sticky: true
toc_label: "목차"
date: 2022.09.01 09:00:00
---

# 학습목표
* 함수의 기초(복습)
* 함수 매개변수를 값으로 전달
* `const` 포인터 매개변수
* 구조체를 처리하는 함수으 설계
* 자기 자신을 호출하는 (재귀) 함수
* 함수의 원형
* 배열을 처리하는 함수의 설계
* 문자열을 처리하는 함수의 설계
* `string` 클래스 객체를 처리하는 함수의 설계
* 함수를 지시하는 포인터


***
# 7.1 함수의 기초(복습)

C++에서 함수를 사용하기 위해 해야하는 작업
* 함수 정의 제공
	* 라이브러리 함수 사용시 이미 정의되어 컴파일되어있음
	* 사용자 정의 함수는 스스로
* 함수 원형 제공
	* 라이브러리 함수 사용시 표준 라이브러리의 헤더 파일을 이용
	* 사용자 정의 함수는 스스로
* 함수 호출

```cpp
// calling.cpp

#include <iostream>
void simple();

int main()
{
	using namespace std;
	cout << "main()에서 simple() 함수를 호출합니다 : \n";
	simple();
	cout << "main()이 simple() 함수와 종료됩니다.\n";
	return 0;
}

void simple()
{
	using namespace std;
	cout << "여기는 simple() 함수입니다.\n";
}
```

## 함수 정의

일반적으로 리턴값이 없는 `void`형 함수는 어떤 종류의 행동을 수행함
리턴값이 있는 함수의 경우 자신을 호출한 함수에게 되돌려줄 리턴값을 만듬

```cpp
void functionName(parameterList)
{
	statement(s)
	return ;
}
```
parameterList : 함수에 전달되는 매개변수의 데이터형과 개수를 지정    
`return` : 함수의 끝을 표시    
* `void`형에서는 생략할 수 있으며 생략시 함수는 닫는 중괄호에서 종료됨
* 상수 / 변수 / 일반적인 표현식이 리턴값이 되고 해당 표현식의 값은 함수에서 선언된 `typeName`형으로 변환되어 리턴됨
* 단, 배열은 리턴값으로 사용할 수 없음
* 일반적으로 리턴값을 CPU에 지정된 레지스터나 메모리에 복사하는 방법으로 리턴함

***

## 함수 원형과 함수 호출

```cpp
// protos.cpp

#include <iostream>
void cheers(int);
double cube(double x);

int main()
{
	using namespace std;
	cheers(5);
	cout << "하나의 수를 입력하십시오 : ";
	double side;
	cin >> side;
	double volume = cube(side);
	cout << "한 변의 길이가 " << side << "센티미터인 정육면체의 부피는 ";
	cout << volume << " 세제곱센티미터입니다.\n";
	cheers(cube(2));
	return 0;
}

void cheers(int n)
{
	using namespace std;
	for (int i = 0; i < n; i++)
		cout << "Cheers! ";
	cout << endl;
}

double cube(double x)
{
	return x * x * x;
}
```

함수 원형은 컴파일러에게 함수의 인터페이스인 리턴값의 데이터형, 매개변수의 개수와 각 매개변수의 데이터형을 알려줌    
* 컴파일러는 함수 원형에 근거하여 에러를 검출
* 특정한 위치에 저장된 함수의 리턴값을 꺼내올 때, 컴파일러는 함수 원형을 보고 데이터형을 판단하여 몇 바이트를 꺼내고 어떻게 처리해야하는지 판단함
* 컴파일러가 함수 원형 대신 함수를 직접 확인할 경우, 라이브러리 함수 등 독립적인 파일에 들어있는 함수들은 찾지 못할 수 있음
* 함수 원형도 하나의 구문이기 때문에 세미콜론으로 끝나야 하며 함수 머리에 세미콜론을 붙이는 것만으로도 완성할 수 있음
* 함수 원형에서의 변수 이름은 생략 가능

함수 원형은 다음과 같은 것들을 보장함
* 컴파일러가 함수의 리턴값을 바르게 처리
* 사용자가 정확한 개수의 매개변수를 사용했는지 컴파일러가 검사
* 사용자가 정확한 데이터형의 매개변수를 사용했는지 컴파일러가 검사, 부정확한 데이터형 사용시 정확한 데이터형으로 변환

함수 원형 비교는 컴파일 시 이루어지며, 이를 정적 데이터형 검사라고 부름    


***
***


# 7.2 함수 매개변수와 값으로 전달하기

함수에 매개변수를 전달하면 해당 함수는 매개변수의 복사본을 가지고 작업함
* 즉, 원본 데이터에는 영향을 주지 않음
* 이 때 전달되는 값을 넘겨받는데 쓰이는 변수를 형식 매개변수(formal parameter)라고 부름
* 함수의 전달되는 값을 실제 매개변수(actual argument)라고 함
* 형식 매개변수를 포함해 함수 안에서 선언된 모든 변수들은 해당 함수 내에서만 활동하며, 함수 종료시 메모리가 해제됨    
이러한 변수들을 지역 변수(local variable)이라고 부름

## 여러 개의 매개변수

```cpp
// twoarg.cpp

#include <iostream>
using namespace std;
void n_chars(char, int);


int main()
{
	int times;
	char ch;

	cout << "문자를 하나 입력하십시오 : ";
	cin >> ch;
	while (ch != 'q')
	{
		cout << "정수를 하나 입력하십시오 : ";
		cin >> times;
		n_chars(ch, times);
		cout << "\n계속하려면 다음 문자를 입력하고, 끝내려면 q를 누르십시오 : ";
		cin >>ch;
	}
	cout << "현재 times의 값은 " << times << "입니다.\n";
	cout << "프로그램을 종료합니다.\n";
	return 0;
}

void n_chars(char c, int n)
{
 while (n-- > 0)
	cout << c;
}
```
함수는 하나 이상의 매개변수를 가질 수 있으며, 매개변수들은 콤마로 분리됨     
이 때 일반적인 변수 선언에서 가능했던 변수 선언의 결합은 허용되지 않음

## 두 개의 매개변수를 사용하는 또 다른 함수

```cpp
// lotto.cpp

#include <iostream>
long double probability(unsigned numbers, unsigned picks);

int main()
{
	using namespace std;
	double total, choices;
	cout << "전체 수의 개수와 뽑을 수의 개수를 입력하십시오 : \n";
	while ((cin >> total >> choices) && choices <= total)
	{
		cout << "당신이 이길 확률은 ";
		cout << probability(total, choices);
		cout << "번 중에서 한번입니다.\n";
		cout <<"다시 두 수를 입력하십시오. (끝내려면 q를 입력) : ";
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}

long double probability(unsigned numbers, unsigned picks)
{
	long double result = 1.0;
	long double n;
	unsigned p;

	for (n = numbers, p = picks; p > 0; n--, p--)
		result = result * n / p;
	return result;
}
```
오버플로를 방지하기 위해 중간 계산값이 작도록 수식을 설정하는게 유리함    


***
***


# 7.3 함수와 배열

```cpp
// arrfun1.cpp

#include <iostream>
const int ArSize = 8;
int sum_arr(int arr[], int n);

int main()
{
	using namespace std;
	int cookies[ArSize] = {1,2,4,8,16,32,64,128};

	int sum = sum_arr(cookies, ArSize);
	cout << "먹은 과자 수 합계 : " << sum << "\n";
	return 0;
}

int sum_arr(int arr[], int n)
{
	int total = 0;
	for (int i = 0; i < n; i++)
		total = total + arr[i];
	return total;
}
```
C++도 C와 마찬가지로 대부분의 상황에서 배열 이름을 포인터처럼 사용함    
`sizeof`를 배열 이름에 적용시 배열의 전체 크기가 바이트 단위로 구해짐    
주소 오퍼레이터 `&`를 배열 이름에 적용하면 전체 배열 주소가 생성됨    

C++의 함수 머리 혹은 함수 원형에서의 `int * arr`와 `int arr[]`는 둘 다 arr이 `int`형을 지시하는 포인터라는 동일한 의미를 지님    
단, 다른 상황에서는 서로 다른 의미를 가지기 때문에 혼용할 수 없음    

## 배열을 매개변수로 사용하는 것의 의미

배열의 실제 내용을 전달하는 것이 아님    
대신 배열의 주소와 배열의 종류, 배열 원소의 개수를 함수에 전달함    
이 정보들을 이용하여 함수는 배열의 원본에 접근할 수 있음    
* 전체 배열을 복사하는 것보다 시간과 메모리가 절약됨    
* 원본을 대상으로 작업하므로 부주의에 의해 데이터가 손상될 가능성이 있으나, 이는 `const` 제한자를 통해 해결할 수 있음

```cpp
// arrfun2.cpp

#include <iostream>
const int ArSize = 8;
int sum_arr(int arr[], int n);

int main()
{
	int cookies[ArSize] = {1,2,4,8,16,32,64,128};

	std::cout << cookies << " = 배열 주소, ";
	std::cout << "sizeof cookies = " << sizeof cookies << std::endl;
	int sum = sum_arr(cookies, ArSize);
	std::cout << "먹은 과자 수 합계 : " << sum << std::endl;
	sum = sum_arr(cookies, 3);
	std::cout << "처음 세 사람은 과자 " << sum << "개를 먹었습니다.\n";
	sum = sum_arr(cookies + 4, 4);
	std::cout << "마지막 네 사람은 과자 " << sum << "개를 먹었습니다.\n";
	return 0;
}

int sum_arr(int arr[], int n)
{
	int total = 0;
	std::cout << arr << " = arr, ";
	std::cout << "sizeof arr = " << sizeof arr << std::endl;
	for (int i = 0; i < n; i++)
		total = total + arr[i];
	return total;
}
```

포인터 자체가 배열의 크기를 나타내지는 않기 때문에 함수에 배열의 크기를 명시적으로 전달해주어야 함    
단, 이 때 대괄호 표기 형태가 아닌 서로 독립된 매개변수의 형태로 넘겨주어야 함    

***

## 배열을 처리하는 함수에 대한 보충

특정 유형의 데이터를 처리하기 위해서는 특정 함수를 작성하는 것이 프로그램의 신뢰성 / 수정의 용이성 / 디버깅의 용이성 등을 포함해 더 유리함     
함수의 목적이 데이터의 변경이 아니라면 배열의 내용 출력시 원본을 변경시키지 않도록 `const` 키워드를 사용하여 보호해야함    
* 매개변수 선언시 `const` 키워드를 추가하면 해당 변수를 읽기 전용 데이터로 취급함

```cpp
// arrfun3.cpp

#include <iostream>
const int Max = 5;
int fill_array(double ar[], int limit);
void show_array(const double ar[], int n);
void revalue(double r, double ar[], int n);

int main()
{
	using namespace std;
	double properties[Max];

	int size = fill_array(properties, Max);
	show_array(properties, size);
	if (size > 0)
	{
		cout << "재평가율을 입력하십시오 : ";
		double factor;
		while (!(cin >> factor))
		{
			cin.clear();
			while (cin.get() != '\n')
				continue;
			cout << "잘못 입력했습니다, 수치를 입력하세요 : ";
		}
		revalue(factor, properties, size);
		show_array(properties, size);
	}
	cout << "프로그램을 종료합니다.\n";
	return 0;
}

int fill_array(double ar[], int limit)
{
	using namespace std;
	double temp;
	int i;
	for (i = 0; i < limit; i++)
	{
		cout << (i + 1) << "번 부동산의 가격 : $";
		cin >> temp;
		if (!cin)
		{
			cin.clear();
			while (cin.get() != '\n')
				continue;
				cout << "입력 불량; 입력 과정을 끝내겠습니다.\n";
				break;
		}
		else if (temp < 0)
			break;
		ar[i] = temp;
	}
	return i;
}

void show_array(const double ar[], int n)
{
	using namespace std;
	for (int i = 0; i < n; i++)
	{
		cout << (i + 1) << "번 부동산 : $";
		cout << ar[i] << endl;
	}
}

void revalue(double r, double ar[], int n)
{
	for (int i = 0; i < n; i++)
		ar[i] *= r;
}
```

각 데이터형에 대해 적절하게 처리할 수 있는 개별 함수를 설계 후, 하나의 프로그램으로 결합하는 방식을 상향시(bottom-up) 프로그래밍이라고 부름    

***

## 배열의 범위를 사용하는 함수

```cpp
// arrfun4.cpp

#include <iostream>
const int ArSize = 8;
int sum_arr(const int * begin, const int * end);

int main()
{
	using namespace std;
	int cookies[ArSize] = {1,2,4,8,16,32,64,128};

	int sum = sum_arr(cookies, cookies + ArSize);
	cout << "먹은 과자 수 합계 : " << sum << std::endl;
	sum = sum_arr(cookies, cookies + 3);
	cout << "처음 세 사람은 과자 " << sum << "개를 먹었습니다.\n";
	sum = sum_arr(cookies + 4, cookies + 8);
	cout << "마지막 네 사람은 과자 " << sum << "개를 먹었습니다.\n";
	return 0;
}

int sum_arr(const int * begin, const int * end)
{
	const int *pt;
	int total = 0;
	for (pt = begin; pt != end; pt++)
		total = total + *pt;
	return total;
}
```

배열의 시작 위치와 배열의 크기를 전달하여 배열을 처리하는 방식 외에도, 원소들의 범위를 지정하는 방법도 존재함    
즉, 배열의 시작을 지시하는 포인터와 배열의 끝을 지시하는 포인터를 전달    
C++ 표준 템플릿 라이브러리에서는 이런 식의 범위접근 방법을 일반화함
* '끝 바로 다음' 이라는 개념을 사용
* 배열의 마지막 원소 다음을 지시하는 포인터로 배열의 끝을 인식
* 포인터를 정확한 순서로 전달하는 것이 중요

***

## 포인터와 const

상수 객체를 지시하는 포인터를 만들시 해당 포인터를 사용하여 포인터가 지시하는 값을 변경할 수 없음    
* 포인터가 지시하는 값 자체가 상수임을 의미하지는 않으므로 포인터를 사용하지 않는다면 값을 변경할 수 있음    
* `const` 변수의 주소를 일반 포인터에 대입하는 것은 불가능함    
* `const`를 사용하는 함수는 `const`와 `const`가 아닌 매개변수를 모두 처리할 수 있으나, `const`를 생략한 함수는 `const`가 아닌 데이터만 처리할 수 있음

포인터 자신을 상수로 만들시 상수 포인터를 사용하여 해당 포인터가 지시하는 장소를 변경할 수 없음    


***
***


# 7.4 함수와 2차원 배열

2차원 배열을 매개변수로 사용시
* `int sum(int (*ar2)[4], int size)` 의 형식으로 4개의 열을 가진 2차원 배열을 선언    
* `int sum(int ar2[][4], int size)` 위와 동일하지만 더 읽기 쉬움    
* 기본형을 지시하는 포인터에 대해서만 `const`를 사용할 수 있기 때문에 위의 경우와 같이 포인터를 지시하는 포인터인 ar2에 `const`를 붙일 수는 없음


***
***


# 7.5 함수와 C스타일의 문자열

## C스타일 문자열을 매개변수로 사용하는 함수

문자열을 나타내는 방법 세가지 모두 `char`형을 지시하는 포인터인 `char *`형이기 때문에 문자열 처리 함수에 매개변수로 사용할 수 있음
* `char`형의 배열
* 큰따옴표로 묶은 문자열 상수(문자열 리터럴)
* 문자열의 주소로 설정된 `char`형을 지시하는 포인터

```cpp
// strgfun.cpp

#include <iostream>
unsigned int c_in_str(const char * str, char ch);

int main()
{
	using namespace std;
	char mmm[15] = "minimum";
	char const *wail = "ululate";

	unsigned int ms = c_in_str(mmm, 'm');
	unsigned int us = c_in_str(wail, 'u');
	cout << mmm << "에는 m이 " << ms << "개 들어있습니다.\n";
	cout << wail << "에는 u가 " << us << "개 들어있습니다.\n";
	return 0;
}

unsigned int c_in_str(const char * str, char ch)
{
	int count = 0;

	while (*str)
	{
		if (*str == ch)
			count++;
		str++;
	}
	return count;
}
```

문자열 원본의 변경을 막기 위해 `const` 제한자를 사용
매개변수로 문자열 전달시 실제로는 문자열을 구성하는 첫 문자의 주소를 전달함    
문자열은 반드시 널 문자로 종결되어야하며, 널 문자가 없을 경우는 문자열이 아닌 그냥 배열이기 때문에 문자열의 크기는 매개변수로 전달할 필요가 없음    
단, 문자열을 처리하는 함수에서 널 문자에 도달할 때까지 문자들을 검사해야함

***

## C스타일 문자열을 리턴하는 함수

```cpp
// strgback.cpp

#include <iostream>
char * buildstr(char c, int n);

int main()
{
	using namespace std;
	int times;
	char ch;

	cout << "문자 하나를 입력하십시오 : ";
	cin >> ch;
	cout << "정수 하나를 입력하십시오 : ";
	cin >> times;
	char *ps = buildstr(ch, times);
	cout << ps << endl;
	delete [] ps;
	ps = buildstr('+', 20);
	cout << ps << "-DONE-" << ps << endl;
	delete [] ps;
	return 0;
}

char * buildstr(char c, int n)
{
	char * pstr = new char[n + 1];
	pstr[n] = '\0';
	while (n-- > 0)
		pstr[n] = c;
	return pstr;
}
```

함수로는 문자열 자체를 리턴할 수 없고 대신 문자열의 주소를 리턴할 수 있음    
buildstr 함수에서 선언한 변수 pstr은 지역변수이기 때문에 함수가 종결되면 자동으로 해제되지만, 함수가 긑나기 전 그 값을 리턴하기 때문에 리턴값이 대입된 ps 포인터를 통해 문자열에 접근할 수 잇음    


***
***


# 7.6 함수와 구조체
